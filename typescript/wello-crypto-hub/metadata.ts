// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: wello-crypto-hub/metadata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "wello.crypto.v1";

export enum ChainStatus {
  CHAIN_STATUS_UNSPECIFIED = 0,
  CHAIN_STATUS_ACTIVE = 1,
  CHAIN_STATUS_DEGRADED = 2,
  CHAIN_STATUS_DISABLED = 3,
  UNRECOGNIZED = -1,
}

export function chainStatusFromJSON(object: any): ChainStatus {
  switch (object) {
    case 0:
    case "CHAIN_STATUS_UNSPECIFIED":
      return ChainStatus.CHAIN_STATUS_UNSPECIFIED;
    case 1:
    case "CHAIN_STATUS_ACTIVE":
      return ChainStatus.CHAIN_STATUS_ACTIVE;
    case 2:
    case "CHAIN_STATUS_DEGRADED":
      return ChainStatus.CHAIN_STATUS_DEGRADED;
    case 3:
    case "CHAIN_STATUS_DISABLED":
      return ChainStatus.CHAIN_STATUS_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChainStatus.UNRECOGNIZED;
  }
}

export function chainStatusToJSON(object: ChainStatus): string {
  switch (object) {
    case ChainStatus.CHAIN_STATUS_UNSPECIFIED:
      return "CHAIN_STATUS_UNSPECIFIED";
    case ChainStatus.CHAIN_STATUS_ACTIVE:
      return "CHAIN_STATUS_ACTIVE";
    case ChainStatus.CHAIN_STATUS_DEGRADED:
      return "CHAIN_STATUS_DEGRADED";
    case ChainStatus.CHAIN_STATUS_DISABLED:
      return "CHAIN_STATUS_DISABLED";
    case ChainStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ChainInfo {
  chainId: string;
  name: string;
  nativeAsset: string;
  rpcEndpoint: string;
  status: ChainStatus;
  updatedAt: Date | undefined;
  metadata: { [key: string]: string };
}

export interface ChainInfo_MetadataEntry {
  key: string;
  value: string;
}

export interface TokenInfo {
  tokenId: string;
  chainId: string;
  symbol: string;
  name: string;
  decimals: number;
  isNative: boolean;
  metadata: { [key: string]: string };
}

export interface TokenInfo_MetadataEntry {
  key: string;
  value: string;
}

export interface ServiceConfig {
  version: string;
  featureFlags: { [key: string]: string };
  updatedAt: Date | undefined;
}

export interface ServiceConfig_FeatureFlagsEntry {
  key: string;
  value: string;
}

export interface GetChainInfoRequest {
  chainId: string;
}

export interface ListChainsRequest {
  status: ChainStatus;
}

export interface ListChainsResponse {
  chains: ChainInfo[];
}

export interface ListSupportedTokensRequest {
  chainId: string;
}

export interface ListSupportedTokensResponse {
  tokens: TokenInfo[];
}

export interface GetServiceConfigRequest {
}

function createBaseChainInfo(): ChainInfo {
  return { chainId: "", name: "", nativeAsset: "", rpcEndpoint: "", status: 0, updatedAt: undefined, metadata: {} };
}

export const ChainInfo: MessageFns<ChainInfo> = {
  encode(message: ChainInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nativeAsset !== "") {
      writer.uint32(26).string(message.nativeAsset);
    }
    if (message.rpcEndpoint !== "") {
      writer.uint32(34).string(message.rpcEndpoint);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ChainInfo_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nativeAsset = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rpcEndpoint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ChainInfo_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfo {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nativeAsset: isSet(object.nativeAsset) ? globalThis.String(object.nativeAsset) : "",
      rpcEndpoint: isSet(object.rpcEndpoint) ? globalThis.String(object.rpcEndpoint) : "",
      status: isSet(object.status) ? chainStatusFromJSON(object.status) : 0,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ChainInfo): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nativeAsset !== "") {
      obj.nativeAsset = message.nativeAsset;
    }
    if (message.rpcEndpoint !== "") {
      obj.rpcEndpoint = message.rpcEndpoint;
    }
    if (message.status !== 0) {
      obj.status = chainStatusToJSON(message.status);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ChainInfo>): ChainInfo {
    return ChainInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainInfo>): ChainInfo {
    const message = createBaseChainInfo();
    message.chainId = object.chainId ?? "";
    message.name = object.name ?? "";
    message.nativeAsset = object.nativeAsset ?? "";
    message.rpcEndpoint = object.rpcEndpoint ?? "";
    message.status = object.status ?? 0;
    message.updatedAt = object.updatedAt ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseChainInfo_MetadataEntry(): ChainInfo_MetadataEntry {
  return { key: "", value: "" };
}

export const ChainInfo_MetadataEntry: MessageFns<ChainInfo_MetadataEntry> = {
  encode(message: ChainInfo_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfo_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfo_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfo_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ChainInfo_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ChainInfo_MetadataEntry>): ChainInfo_MetadataEntry {
    return ChainInfo_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainInfo_MetadataEntry>): ChainInfo_MetadataEntry {
    const message = createBaseChainInfo_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTokenInfo(): TokenInfo {
  return { tokenId: "", chainId: "", symbol: "", name: "", decimals: 0, isNative: false, metadata: {} };
}

export const TokenInfo: MessageFns<TokenInfo> = {
  encode(message: TokenInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).uint32(message.decimals);
    }
    if (message.isNative !== false) {
      writer.uint32(48).bool(message.isNative);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TokenInfo_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = TokenInfo_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenInfo {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TokenInfo): unknown {
    const obj: any = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TokenInfo>): TokenInfo {
    return TokenInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenInfo>): TokenInfo {
    const message = createBaseTokenInfo();
    message.tokenId = object.tokenId ?? "";
    message.chainId = object.chainId ?? "";
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.decimals = object.decimals ?? 0;
    message.isNative = object.isNative ?? false;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTokenInfo_MetadataEntry(): TokenInfo_MetadataEntry {
  return { key: "", value: "" };
}

export const TokenInfo_MetadataEntry: MessageFns<TokenInfo_MetadataEntry> = {
  encode(message: TokenInfo_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenInfo_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenInfo_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenInfo_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TokenInfo_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TokenInfo_MetadataEntry>): TokenInfo_MetadataEntry {
    return TokenInfo_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenInfo_MetadataEntry>): TokenInfo_MetadataEntry {
    const message = createBaseTokenInfo_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceConfig(): ServiceConfig {
  return { version: "", featureFlags: {}, updatedAt: undefined };
}

export const ServiceConfig: MessageFns<ServiceConfig> = {
  encode(message: ServiceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    Object.entries(message.featureFlags).forEach(([key, value]) => {
      ServiceConfig_FeatureFlagsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ServiceConfig_FeatureFlagsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.featureFlags[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConfig {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      featureFlags: isObject(object.featureFlags)
        ? Object.entries(object.featureFlags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: ServiceConfig): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.featureFlags) {
      const entries = Object.entries(message.featureFlags);
      if (entries.length > 0) {
        obj.featureFlags = {};
        entries.forEach(([k, v]) => {
          obj.featureFlags[k] = v;
        });
      }
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceConfig>): ServiceConfig {
    return ServiceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceConfig>): ServiceConfig {
    const message = createBaseServiceConfig();
    message.version = object.version ?? "";
    message.featureFlags = Object.entries(object.featureFlags ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseServiceConfig_FeatureFlagsEntry(): ServiceConfig_FeatureFlagsEntry {
  return { key: "", value: "" };
}

export const ServiceConfig_FeatureFlagsEntry: MessageFns<ServiceConfig_FeatureFlagsEntry> = {
  encode(message: ServiceConfig_FeatureFlagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConfig_FeatureFlagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConfig_FeatureFlagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConfig_FeatureFlagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ServiceConfig_FeatureFlagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceConfig_FeatureFlagsEntry>): ServiceConfig_FeatureFlagsEntry {
    return ServiceConfig_FeatureFlagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceConfig_FeatureFlagsEntry>): ServiceConfig_FeatureFlagsEntry {
    const message = createBaseServiceConfig_FeatureFlagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetChainInfoRequest(): GetChainInfoRequest {
  return { chainId: "" };
}

export const GetChainInfoRequest: MessageFns<GetChainInfoRequest> = {
  encode(message: GetChainInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainInfoRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: GetChainInfoRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetChainInfoRequest>): GetChainInfoRequest {
    return GetChainInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChainInfoRequest>): GetChainInfoRequest {
    const message = createBaseGetChainInfoRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseListChainsRequest(): ListChainsRequest {
  return { status: 0 };
}

export const ListChainsRequest: MessageFns<ListChainsRequest> = {
  encode(message: ListChainsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChainsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChainsRequest {
    return { status: isSet(object.status) ? chainStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: ListChainsRequest): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = chainStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ListChainsRequest>): ListChainsRequest {
    return ListChainsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChainsRequest>): ListChainsRequest {
    const message = createBaseListChainsRequest();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseListChainsResponse(): ListChainsResponse {
  return { chains: [] };
}

export const ListChainsResponse: MessageFns<ListChainsResponse> = {
  encode(message: ListChainsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chains) {
      ChainInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChainsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chains.push(ChainInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChainsResponse {
    return {
      chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => ChainInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListChainsResponse): unknown {
    const obj: any = {};
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => ChainInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListChainsResponse>): ListChainsResponse {
    return ListChainsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChainsResponse>): ListChainsResponse {
    const message = createBaseListChainsResponse();
    message.chains = object.chains?.map((e) => ChainInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSupportedTokensRequest(): ListSupportedTokensRequest {
  return { chainId: "" };
}

export const ListSupportedTokensRequest: MessageFns<ListSupportedTokensRequest> = {
  encode(message: ListSupportedTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSupportedTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSupportedTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSupportedTokensRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: ListSupportedTokensRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSupportedTokensRequest>): ListSupportedTokensRequest {
    return ListSupportedTokensRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSupportedTokensRequest>): ListSupportedTokensRequest {
    const message = createBaseListSupportedTokensRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseListSupportedTokensResponse(): ListSupportedTokensResponse {
  return { tokens: [] };
}

export const ListSupportedTokensResponse: MessageFns<ListSupportedTokensResponse> = {
  encode(message: ListSupportedTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokens) {
      TokenInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSupportedTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSupportedTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokens.push(TokenInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSupportedTokensResponse {
    return {
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => TokenInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSupportedTokensResponse): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => TokenInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSupportedTokensResponse>): ListSupportedTokensResponse {
    return ListSupportedTokensResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSupportedTokensResponse>): ListSupportedTokensResponse {
    const message = createBaseListSupportedTokensResponse();
    message.tokens = object.tokens?.map((e) => TokenInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetServiceConfigRequest(): GetServiceConfigRequest {
  return {};
}

export const GetServiceConfigRequest: MessageFns<GetServiceConfigRequest> = {
  encode(_: GetServiceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetServiceConfigRequest {
    return {};
  },

  toJSON(_: GetServiceConfigRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetServiceConfigRequest>): GetServiceConfigRequest {
    return GetServiceConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetServiceConfigRequest>): GetServiceConfigRequest {
    const message = createBaseGetServiceConfigRequest();
    return message;
  },
};

export type MetadataServiceDefinition = typeof MetadataServiceDefinition;
export const MetadataServiceDefinition = {
  name: "MetadataService",
  fullName: "wello.crypto.v1.MetadataService",
  methods: {
    getChainInfo: {
      name: "GetChainInfo",
      requestType: GetChainInfoRequest,
      requestStream: false,
      responseType: ChainInfo,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              23,
              18,
              21,
              47,
              118,
              49,
              47,
              99,
              104,
              97,
              105,
              110,
              115,
              47,
              123,
              99,
              104,
              97,
              105,
              110,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    listChains: {
      name: "ListChains",
      requestType: ListChainsRequest,
      requestStream: false,
      responseType: ListChainsResponse,
      responseStream: false,
      options: {
        _unknownFields: { 578365826: [new Uint8Array([12, 18, 10, 47, 118, 49, 47, 99, 104, 97, 105, 110, 115])] },
      },
    },
    listSupportedTokens: {
      name: "ListSupportedTokens",
      requestType: ListSupportedTokensRequest,
      requestStream: false,
      responseType: ListSupportedTokensResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              30,
              18,
              28,
              47,
              118,
              49,
              47,
              99,
              104,
              97,
              105,
              110,
              115,
              47,
              123,
              99,
              104,
              97,
              105,
              110,
              95,
              105,
              100,
              125,
              47,
              116,
              111,
              107,
              101,
              110,
              115,
            ]),
          ],
        },
      },
    },
    getServiceConfig: {
      name: "GetServiceConfig",
      requestType: GetServiceConfigRequest,
      requestStream: false,
      responseType: ServiceConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              20,
              18,
              18,
              47,
              118,
              49,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              45,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface MetadataServiceImplementation<CallContextExt = {}> {
  getChainInfo(request: GetChainInfoRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ChainInfo>>;
  listChains(
    request: ListChainsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListChainsResponse>>;
  listSupportedTokens(
    request: ListSupportedTokensRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSupportedTokensResponse>>;
  getServiceConfig(
    request: GetServiceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceConfig>>;
}

export interface MetadataServiceClient<CallOptionsExt = {}> {
  getChainInfo(request: DeepPartial<GetChainInfoRequest>, options?: CallOptions & CallOptionsExt): Promise<ChainInfo>;
  listChains(
    request: DeepPartial<ListChainsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListChainsResponse>;
  listSupportedTokens(
    request: DeepPartial<ListSupportedTokensRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSupportedTokensResponse>;
  getServiceConfig(
    request: DeepPartial<GetServiceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceConfig>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
