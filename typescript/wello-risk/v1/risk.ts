// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: wello-risk/v1/risk.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Struct } from "../../google/protobuf/struct";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "risk.v1";

export enum DecisionStatus {
  DECISION_STATUS_UNSPECIFIED = 0,
  DECISION_STATUS_APPROVED = 1,
  DECISION_STATUS_REVIEW = 2,
  DECISION_STATUS_DECLINED = 3,
  UNRECOGNIZED = -1,
}

export function decisionStatusFromJSON(object: any): DecisionStatus {
  switch (object) {
    case 0:
    case "DECISION_STATUS_UNSPECIFIED":
      return DecisionStatus.DECISION_STATUS_UNSPECIFIED;
    case 1:
    case "DECISION_STATUS_APPROVED":
      return DecisionStatus.DECISION_STATUS_APPROVED;
    case 2:
    case "DECISION_STATUS_REVIEW":
      return DecisionStatus.DECISION_STATUS_REVIEW;
    case 3:
    case "DECISION_STATUS_DECLINED":
      return DecisionStatus.DECISION_STATUS_DECLINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DecisionStatus.UNRECOGNIZED;
  }
}

export function decisionStatusToJSON(object: DecisionStatus): string {
  switch (object) {
    case DecisionStatus.DECISION_STATUS_UNSPECIFIED:
      return "DECISION_STATUS_UNSPECIFIED";
    case DecisionStatus.DECISION_STATUS_APPROVED:
      return "DECISION_STATUS_APPROVED";
    case DecisionStatus.DECISION_STATUS_REVIEW:
      return "DECISION_STATUS_REVIEW";
    case DecisionStatus.DECISION_STATUS_DECLINED:
      return "DECISION_STATUS_DECLINED";
    case DecisionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EvaluateDecisionRequest {
  decisionId: string;
  subjectId: string;
  scenario: string;
  features: { [key: string]: any } | undefined;
}

export interface EvaluateDecisionResponse {
  status: DecisionStatus;
  reason: string;
  appliedRules: string[];
  scoreComponents: { [key: string]: number };
  overallScore: number;
}

export interface EvaluateDecisionResponse_ScoreComponentsEntry {
  key: string;
  value: number;
}

export interface ReportEventRequest {
  eventId: string;
  subjectId: string;
  eventType: string;
  occurredAt: Date | undefined;
  payload: { [key: string]: any } | undefined;
}

export interface ReportEventResponse {
  accepted: boolean;
  message: string;
}

export interface GetLimitsRequest {
  subjectId: string;
}

export interface GetLimitsResponse {
  limits: RiskLimit[];
}

export interface RiskLimit {
  limitId: string;
  name: string;
  threshold: number;
  currency: string;
  window: string;
  refreshedAt: Date | undefined;
}

export interface ListRulesRequest {
  includeInactive: boolean;
}

export interface ListRulesResponse {
  rules: RiskRule[];
}

export interface RiskRule {
  ruleId: string;
  name: string;
  description: string;
  enabled: boolean;
  updatedAt: Date | undefined;
}

export interface EvaluateVelocityRequest {
  subjectId: string;
  action: string;
  channel: string;
  signals: string[];
  window: string;
  count: number;
  observedAt: Date | undefined;
  context: { [key: string]: any } | undefined;
}

export interface EvaluateVelocityResponse {
  status: DecisionStatus;
  allowed: boolean;
  policyId: string;
  reason: string;
  anomalyScores: { [key: string]: number };
}

export interface EvaluateVelocityResponse_AnomalyScoresEntry {
  key: string;
  value: number;
}

function createBaseEvaluateDecisionRequest(): EvaluateDecisionRequest {
  return { decisionId: "", subjectId: "", scenario: "", features: undefined };
}

export const EvaluateDecisionRequest: MessageFns<EvaluateDecisionRequest> = {
  encode(message: EvaluateDecisionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decisionId !== "") {
      writer.uint32(10).string(message.decisionId);
    }
    if (message.subjectId !== "") {
      writer.uint32(18).string(message.subjectId);
    }
    if (message.scenario !== "") {
      writer.uint32(26).string(message.scenario);
    }
    if (message.features !== undefined) {
      Struct.encode(Struct.wrap(message.features), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateDecisionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateDecisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.decisionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scenario = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.features = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateDecisionRequest {
    return {
      decisionId: isSet(object.decisionId) ? globalThis.String(object.decisionId) : "",
      subjectId: isSet(object.subjectId) ? globalThis.String(object.subjectId) : "",
      scenario: isSet(object.scenario) ? globalThis.String(object.scenario) : "",
      features: isObject(object.features) ? object.features : undefined,
    };
  },

  toJSON(message: EvaluateDecisionRequest): unknown {
    const obj: any = {};
    if (message.decisionId !== "") {
      obj.decisionId = message.decisionId;
    }
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.scenario !== "") {
      obj.scenario = message.scenario;
    }
    if (message.features !== undefined) {
      obj.features = message.features;
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluateDecisionRequest>): EvaluateDecisionRequest {
    return EvaluateDecisionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluateDecisionRequest>): EvaluateDecisionRequest {
    const message = createBaseEvaluateDecisionRequest();
    message.decisionId = object.decisionId ?? "";
    message.subjectId = object.subjectId ?? "";
    message.scenario = object.scenario ?? "";
    message.features = object.features ?? undefined;
    return message;
  },
};

function createBaseEvaluateDecisionResponse(): EvaluateDecisionResponse {
  return { status: 0, reason: "", appliedRules: [], scoreComponents: {}, overallScore: 0 };
}

export const EvaluateDecisionResponse: MessageFns<EvaluateDecisionResponse> = {
  encode(message: EvaluateDecisionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    for (const v of message.appliedRules) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.scoreComponents).forEach(([key, value]) => {
      EvaluateDecisionResponse_ScoreComponentsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.overallScore !== 0) {
      writer.uint32(41).double(message.overallScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateDecisionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateDecisionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appliedRules.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = EvaluateDecisionResponse_ScoreComponentsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.scoreComponents[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.overallScore = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateDecisionResponse {
    return {
      status: isSet(object.status) ? decisionStatusFromJSON(object.status) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      appliedRules: globalThis.Array.isArray(object?.appliedRules)
        ? object.appliedRules.map((e: any) => globalThis.String(e))
        : [],
      scoreComponents: isObject(object.scoreComponents)
        ? Object.entries(object.scoreComponents).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      overallScore: isSet(object.overallScore) ? globalThis.Number(object.overallScore) : 0,
    };
  },

  toJSON(message: EvaluateDecisionResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = decisionStatusToJSON(message.status);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.appliedRules?.length) {
      obj.appliedRules = message.appliedRules;
    }
    if (message.scoreComponents) {
      const entries = Object.entries(message.scoreComponents);
      if (entries.length > 0) {
        obj.scoreComponents = {};
        entries.forEach(([k, v]) => {
          obj.scoreComponents[k] = v;
        });
      }
    }
    if (message.overallScore !== 0) {
      obj.overallScore = message.overallScore;
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluateDecisionResponse>): EvaluateDecisionResponse {
    return EvaluateDecisionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluateDecisionResponse>): EvaluateDecisionResponse {
    const message = createBaseEvaluateDecisionResponse();
    message.status = object.status ?? 0;
    message.reason = object.reason ?? "";
    message.appliedRules = object.appliedRules?.map((e) => e) || [];
    message.scoreComponents = Object.entries(object.scoreComponents ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.overallScore = object.overallScore ?? 0;
    return message;
  },
};

function createBaseEvaluateDecisionResponse_ScoreComponentsEntry(): EvaluateDecisionResponse_ScoreComponentsEntry {
  return { key: "", value: 0 };
}

export const EvaluateDecisionResponse_ScoreComponentsEntry: MessageFns<EvaluateDecisionResponse_ScoreComponentsEntry> =
  {
    encode(
      message: EvaluateDecisionResponse_ScoreComponentsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(17).double(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EvaluateDecisionResponse_ScoreComponentsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEvaluateDecisionResponse_ScoreComponentsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 17) {
              break;
            }

            message.value = reader.double();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EvaluateDecisionResponse_ScoreComponentsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      };
    },

    toJSON(message: EvaluateDecisionResponse_ScoreComponentsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },

    create(
      base?: DeepPartial<EvaluateDecisionResponse_ScoreComponentsEntry>,
    ): EvaluateDecisionResponse_ScoreComponentsEntry {
      return EvaluateDecisionResponse_ScoreComponentsEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<EvaluateDecisionResponse_ScoreComponentsEntry>,
    ): EvaluateDecisionResponse_ScoreComponentsEntry {
      const message = createBaseEvaluateDecisionResponse_ScoreComponentsEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? 0;
      return message;
    },
  };

function createBaseReportEventRequest(): ReportEventRequest {
  return { eventId: "", subjectId: "", eventType: "", occurredAt: undefined, payload: undefined };
}

export const ReportEventRequest: MessageFns<ReportEventRequest> = {
  encode(message: ReportEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.subjectId !== "") {
      writer.uint32(18).string(message.subjectId);
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.occurredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.occurredAt), writer.uint32(34).fork()).join();
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.occurredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportEventRequest {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      subjectId: isSet(object.subjectId) ? globalThis.String(object.subjectId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      occurredAt: isSet(object.occurredAt) ? fromJsonTimestamp(object.occurredAt) : undefined,
      payload: isObject(object.payload) ? object.payload : undefined,
    };
  },

  toJSON(message: ReportEventRequest): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.occurredAt !== undefined) {
      obj.occurredAt = message.occurredAt.toISOString();
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportEventRequest>): ReportEventRequest {
    return ReportEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportEventRequest>): ReportEventRequest {
    const message = createBaseReportEventRequest();
    message.eventId = object.eventId ?? "";
    message.subjectId = object.subjectId ?? "";
    message.eventType = object.eventType ?? "";
    message.occurredAt = object.occurredAt ?? undefined;
    message.payload = object.payload ?? undefined;
    return message;
  },
};

function createBaseReportEventResponse(): ReportEventResponse {
  return { accepted: false, message: "" };
}

export const ReportEventResponse: MessageFns<ReportEventResponse> = {
  encode(message: ReportEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accepted !== false) {
      writer.uint32(8).bool(message.accepted);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accepted = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportEventResponse {
    return {
      accepted: isSet(object.accepted) ? globalThis.Boolean(object.accepted) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ReportEventResponse): unknown {
    const obj: any = {};
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportEventResponse>): ReportEventResponse {
    return ReportEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportEventResponse>): ReportEventResponse {
    const message = createBaseReportEventResponse();
    message.accepted = object.accepted ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetLimitsRequest(): GetLimitsRequest {
  return { subjectId: "" };
}

export const GetLimitsRequest: MessageFns<GetLimitsRequest> = {
  encode(message: GetLimitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectId !== "") {
      writer.uint32(10).string(message.subjectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLimitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLimitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLimitsRequest {
    return { subjectId: isSet(object.subjectId) ? globalThis.String(object.subjectId) : "" };
  },

  toJSON(message: GetLimitsRequest): unknown {
    const obj: any = {};
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLimitsRequest>): GetLimitsRequest {
    return GetLimitsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLimitsRequest>): GetLimitsRequest {
    const message = createBaseGetLimitsRequest();
    message.subjectId = object.subjectId ?? "";
    return message;
  },
};

function createBaseGetLimitsResponse(): GetLimitsResponse {
  return { limits: [] };
}

export const GetLimitsResponse: MessageFns<GetLimitsResponse> = {
  encode(message: GetLimitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.limits) {
      RiskLimit.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLimitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLimitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.limits.push(RiskLimit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLimitsResponse {
    return {
      limits: globalThis.Array.isArray(object?.limits) ? object.limits.map((e: any) => RiskLimit.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetLimitsResponse): unknown {
    const obj: any = {};
    if (message.limits?.length) {
      obj.limits = message.limits.map((e) => RiskLimit.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetLimitsResponse>): GetLimitsResponse {
    return GetLimitsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLimitsResponse>): GetLimitsResponse {
    const message = createBaseGetLimitsResponse();
    message.limits = object.limits?.map((e) => RiskLimit.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRiskLimit(): RiskLimit {
  return { limitId: "", name: "", threshold: 0, currency: "", window: "", refreshedAt: undefined };
}

export const RiskLimit: MessageFns<RiskLimit> = {
  encode(message: RiskLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limitId !== "") {
      writer.uint32(10).string(message.limitId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.threshold !== 0) {
      writer.uint32(25).double(message.threshold);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.window !== "") {
      writer.uint32(42).string(message.window);
    }
    if (message.refreshedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.refreshedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RiskLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRiskLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.limitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.threshold = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.window = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refreshedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RiskLimit {
    return {
      limitId: isSet(object.limitId) ? globalThis.String(object.limitId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      window: isSet(object.window) ? globalThis.String(object.window) : "",
      refreshedAt: isSet(object.refreshedAt) ? fromJsonTimestamp(object.refreshedAt) : undefined,
    };
  },

  toJSON(message: RiskLimit): unknown {
    const obj: any = {};
    if (message.limitId !== "") {
      obj.limitId = message.limitId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.window !== "") {
      obj.window = message.window;
    }
    if (message.refreshedAt !== undefined) {
      obj.refreshedAt = message.refreshedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RiskLimit>): RiskLimit {
    return RiskLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RiskLimit>): RiskLimit {
    const message = createBaseRiskLimit();
    message.limitId = object.limitId ?? "";
    message.name = object.name ?? "";
    message.threshold = object.threshold ?? 0;
    message.currency = object.currency ?? "";
    message.window = object.window ?? "";
    message.refreshedAt = object.refreshedAt ?? undefined;
    return message;
  },
};

function createBaseListRulesRequest(): ListRulesRequest {
  return { includeInactive: false };
}

export const ListRulesRequest: MessageFns<ListRulesRequest> = {
  encode(message: ListRulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeInactive !== false) {
      writer.uint32(8).bool(message.includeInactive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRulesRequest {
    return { includeInactive: isSet(object.includeInactive) ? globalThis.Boolean(object.includeInactive) : false };
  },

  toJSON(message: ListRulesRequest): unknown {
    const obj: any = {};
    if (message.includeInactive !== false) {
      obj.includeInactive = message.includeInactive;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRulesRequest>): ListRulesRequest {
    return ListRulesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRulesRequest>): ListRulesRequest {
    const message = createBaseListRulesRequest();
    message.includeInactive = object.includeInactive ?? false;
    return message;
  },
};

function createBaseListRulesResponse(): ListRulesResponse {
  return { rules: [] };
}

export const ListRulesResponse: MessageFns<ListRulesResponse> = {
  encode(message: ListRulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rules) {
      RiskRule.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rules.push(RiskRule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRulesResponse {
    return { rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => RiskRule.fromJSON(e)) : [] };
  },

  toJSON(message: ListRulesResponse): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => RiskRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListRulesResponse>): ListRulesResponse {
    return ListRulesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRulesResponse>): ListRulesResponse {
    const message = createBaseListRulesResponse();
    message.rules = object.rules?.map((e) => RiskRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRiskRule(): RiskRule {
  return { ruleId: "", name: "", description: "", enabled: false, updatedAt: undefined };
}

export const RiskRule: MessageFns<RiskRule> = {
  encode(message: RiskRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleId !== "") {
      writer.uint32(10).string(message.ruleId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.enabled !== false) {
      writer.uint32(32).bool(message.enabled);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RiskRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRiskRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RiskRule {
    return {
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: RiskRule): unknown {
    const obj: any = {};
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RiskRule>): RiskRule {
    return RiskRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RiskRule>): RiskRule {
    const message = createBaseRiskRule();
    message.ruleId = object.ruleId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.enabled = object.enabled ?? false;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseEvaluateVelocityRequest(): EvaluateVelocityRequest {
  return {
    subjectId: "",
    action: "",
    channel: "",
    signals: [],
    window: "",
    count: 0,
    observedAt: undefined,
    context: undefined,
  };
}

export const EvaluateVelocityRequest: MessageFns<EvaluateVelocityRequest> = {
  encode(message: EvaluateVelocityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectId !== "") {
      writer.uint32(10).string(message.subjectId);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.channel !== "") {
      writer.uint32(26).string(message.channel);
    }
    for (const v of message.signals) {
      writer.uint32(34).string(v!);
    }
    if (message.window !== "") {
      writer.uint32(42).string(message.window);
    }
    if (message.count !== 0) {
      writer.uint32(48).uint64(message.count);
    }
    if (message.observedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.observedAt), writer.uint32(58).fork()).join();
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateVelocityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateVelocityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signals.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.window = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.count = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.observedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateVelocityRequest {
    return {
      subjectId: isSet(object.subjectId) ? globalThis.String(object.subjectId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      signals: globalThis.Array.isArray(object?.signals) ? object.signals.map((e: any) => globalThis.String(e)) : [],
      window: isSet(object.window) ? globalThis.String(object.window) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      observedAt: isSet(object.observedAt) ? fromJsonTimestamp(object.observedAt) : undefined,
      context: isObject(object.context) ? object.context : undefined,
    };
  },

  toJSON(message: EvaluateVelocityRequest): unknown {
    const obj: any = {};
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.signals?.length) {
      obj.signals = message.signals;
    }
    if (message.window !== "") {
      obj.window = message.window;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.observedAt !== undefined) {
      obj.observedAt = message.observedAt.toISOString();
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluateVelocityRequest>): EvaluateVelocityRequest {
    return EvaluateVelocityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluateVelocityRequest>): EvaluateVelocityRequest {
    const message = createBaseEvaluateVelocityRequest();
    message.subjectId = object.subjectId ?? "";
    message.action = object.action ?? "";
    message.channel = object.channel ?? "";
    message.signals = object.signals?.map((e) => e) || [];
    message.window = object.window ?? "";
    message.count = object.count ?? 0;
    message.observedAt = object.observedAt ?? undefined;
    message.context = object.context ?? undefined;
    return message;
  },
};

function createBaseEvaluateVelocityResponse(): EvaluateVelocityResponse {
  return { status: 0, allowed: false, policyId: "", reason: "", anomalyScores: {} };
}

export const EvaluateVelocityResponse: MessageFns<EvaluateVelocityResponse> = {
  encode(message: EvaluateVelocityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.allowed !== false) {
      writer.uint32(16).bool(message.allowed);
    }
    if (message.policyId !== "") {
      writer.uint32(26).string(message.policyId);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    Object.entries(message.anomalyScores).forEach(([key, value]) => {
      EvaluateVelocityResponse_AnomalyScoresEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateVelocityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateVelocityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allowed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.policyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = EvaluateVelocityResponse_AnomalyScoresEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.anomalyScores[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateVelocityResponse {
    return {
      status: isSet(object.status) ? decisionStatusFromJSON(object.status) : 0,
      allowed: isSet(object.allowed) ? globalThis.Boolean(object.allowed) : false,
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      anomalyScores: isObject(object.anomalyScores)
        ? Object.entries(object.anomalyScores).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: EvaluateVelocityResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = decisionStatusToJSON(message.status);
    }
    if (message.allowed !== false) {
      obj.allowed = message.allowed;
    }
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.anomalyScores) {
      const entries = Object.entries(message.anomalyScores);
      if (entries.length > 0) {
        obj.anomalyScores = {};
        entries.forEach(([k, v]) => {
          obj.anomalyScores[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluateVelocityResponse>): EvaluateVelocityResponse {
    return EvaluateVelocityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluateVelocityResponse>): EvaluateVelocityResponse {
    const message = createBaseEvaluateVelocityResponse();
    message.status = object.status ?? 0;
    message.allowed = object.allowed ?? false;
    message.policyId = object.policyId ?? "";
    message.reason = object.reason ?? "";
    message.anomalyScores = Object.entries(object.anomalyScores ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseEvaluateVelocityResponse_AnomalyScoresEntry(): EvaluateVelocityResponse_AnomalyScoresEntry {
  return { key: "", value: 0 };
}

export const EvaluateVelocityResponse_AnomalyScoresEntry: MessageFns<EvaluateVelocityResponse_AnomalyScoresEntry> = {
  encode(
    message: EvaluateVelocityResponse_AnomalyScoresEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateVelocityResponse_AnomalyScoresEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateVelocityResponse_AnomalyScoresEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateVelocityResponse_AnomalyScoresEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: EvaluateVelocityResponse_AnomalyScoresEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluateVelocityResponse_AnomalyScoresEntry>): EvaluateVelocityResponse_AnomalyScoresEntry {
    return EvaluateVelocityResponse_AnomalyScoresEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<EvaluateVelocityResponse_AnomalyScoresEntry>,
  ): EvaluateVelocityResponse_AnomalyScoresEntry {
    const message = createBaseEvaluateVelocityResponse_AnomalyScoresEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

export type RiskServiceDefinition = typeof RiskServiceDefinition;
export const RiskServiceDefinition = {
  name: "RiskService",
  fullName: "risk.v1.RiskService",
  methods: {
    evaluateDecision: {
      name: "EvaluateDecision",
      requestType: EvaluateDecisionRequest,
      requestStream: false,
      responseType: EvaluateDecisionResponse,
      responseStream: false,
      options: {},
    },
    reportEvent: {
      name: "ReportEvent",
      requestType: ReportEventRequest,
      requestStream: false,
      responseType: ReportEventResponse,
      responseStream: false,
      options: {},
    },
    getLimits: {
      name: "GetLimits",
      requestType: GetLimitsRequest,
      requestStream: false,
      responseType: GetLimitsResponse,
      responseStream: false,
      options: {},
    },
    listRules: {
      name: "ListRules",
      requestType: ListRulesRequest,
      requestStream: false,
      responseType: ListRulesResponse,
      responseStream: false,
      options: {},
    },
    evaluateVelocity: {
      name: "EvaluateVelocity",
      requestType: EvaluateVelocityRequest,
      requestStream: false,
      responseType: EvaluateVelocityResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface RiskServiceImplementation<CallContextExt = {}> {
  evaluateDecision(
    request: EvaluateDecisionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EvaluateDecisionResponse>>;
  reportEvent(
    request: ReportEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReportEventResponse>>;
  getLimits(request: GetLimitsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetLimitsResponse>>;
  listRules(request: ListRulesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListRulesResponse>>;
  evaluateVelocity(
    request: EvaluateVelocityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EvaluateVelocityResponse>>;
}

export interface RiskServiceClient<CallOptionsExt = {}> {
  evaluateDecision(
    request: DeepPartial<EvaluateDecisionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EvaluateDecisionResponse>;
  reportEvent(
    request: DeepPartial<ReportEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReportEventResponse>;
  getLimits(request: DeepPartial<GetLimitsRequest>, options?: CallOptions & CallOptionsExt): Promise<GetLimitsResponse>;
  listRules(request: DeepPartial<ListRulesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListRulesResponse>;
  evaluateVelocity(
    request: DeepPartial<EvaluateVelocityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EvaluateVelocityResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
