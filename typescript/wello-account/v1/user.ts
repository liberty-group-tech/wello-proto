// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: wello-account/v1/user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Empty } from "../../google/protobuf/empty";

export const protobufPackage = "user.service.v1";

export enum UserStatus {
  Normal = 0,
  Disabled = 1,
  Deleted = 2,
  UNRECOGNIZED = -1,
}

export function userStatusFromJSON(object: any): UserStatus {
  switch (object) {
    case 0:
    case "Normal":
      return UserStatus.Normal;
    case 1:
    case "Disabled":
      return UserStatus.Disabled;
    case 2:
    case "Deleted":
      return UserStatus.Deleted;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserStatus.UNRECOGNIZED;
  }
}

export function userStatusToJSON(object: UserStatus): string {
  switch (object) {
    case UserStatus.Normal:
      return "Normal";
    case UserStatus.Disabled:
      return "Disabled";
    case UserStatus.Deleted:
      return "Deleted";
    case UserStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetSupportCountriesResp {
  count: number;
  list: MobileCodeItem[];
}

export interface MobileCodeItem {
  /** 手机区号 */
  mobileCode: string;
  /** 对应的国家Logo */
  flag: string;
  countryCode: string;
  countryName: string;
}

export interface SignFlowCreateReq {
  signFlowType: string;
  mobileCode: string;
  mobileNumber: string;
  email: string;
  oauthPlatform: string;
  locale: string;
  clientType: string;
  ip: string;
  countryCode: string;
}

export interface SignFlowCreateResp {
  /** FlowID */
  flowId: string;
}

export interface SignFlowSendReq {
  flowId: string;
}

export interface SignFlowValidateReq {
  flowId: string;
  data: string;
  userAgent: string;
  forterMobileUid: string;
  brand: string;
  deviceModel: string;
  osVersion: string;
  appBuild: number;
  appVersion: string;
}

export interface SignFlowValidateResp {
  refreshToken: string;
  accessToken: string;
  signup: boolean;
}

export interface LoginByPasswordReq {
  mobileCode: string;
  mobileNumber: string;
  countryCode: string;
  email: string;
  locale: string;
  userAgent: string;
  clientType: string;
  ip: string;
  forterMobileUid: string;
  password: string;
}

export interface LoginByPasswordResp {
  accessToken: string;
  refreshToken: string;
}

export interface CheckAccessTokenReq {
  accessToken: string;
}

export interface CheckAccessTokenReply {
  userId: number;
  ok: boolean;
}

export interface GetAccessTokenReq {
  refreshToken: string;
}

export interface GetAccessTokenReply {
  accessToken: string;
}

export interface GetUserInfoReq {
  userId: number;
  internalUserId: string;
  externalUserId: string;
}

export interface GetUserInfoReply {
  userId: number;
  status: UserStatus;
  locale: string;
  username: string;
  nickname: string;
  avatar: string;
  fiatCurrency: string;
  password: boolean;
  internalUserId: string;
  externalUserId: string;
  dob: string;
  email: string;
  mobile: string;
  notificationOn: boolean;
  intercomHmacIos: string;
  intercomHmacAndroid: string;
  inviteCode: string;
}

export interface QueryUserInfoReq {
  userIds: number[];
}

export interface QueryUserInfoReply {
  list: GetUserInfoReply[];
}

export interface GetUserMobileReq {
  userId: number;
}

export interface GetUserMobileReply {
  userId: number;
  mobileCode: string;
  mobileNumber: string;
}

export interface GetUserEmailReq {
  userId: number;
}

export interface GetUserEmailReply {
  userId: number;
  email: string;
}

export interface CheckUsernameReq {
  userId: number;
  username: string;
}

export interface SetupUsernameReq {
  userId: number;
  username: string;
}

export interface SetupNicknameReq {
  userId: number;
  nickname: string;
}

export interface SetupDobReq {
  userId: number;
  dob: string;
}

export interface SetupAvatarReq {
  userId: number;
  avatar: string;
}

export interface UpdateFiatCurrencyReq {
  userId: number;
  fiatCurrency: string;
}

export interface UpdateNotificationOnReq {
  userId: number;
  notificationOn: boolean;
}

export interface SetupPasswordReq {
  userId: number;
  oldPassword: string;
  newPassword: string;
}

export interface BindEmailFlowCreateReq {
  userId: number;
  email: string;
}

export interface BindEmailFlowCreateReply {
  flowId: string;
}

export interface BindEmailFlowSendReq {
  flowId: string;
}

export interface BindEmailFlowValidateReq {
  flowId: string;
  code: string;
}

export interface BindOAuthFlowCreateReq {
  userId: number;
  platform: string;
}

export interface BindOAuthFlowCreateReply {
  flowId: string;
}

export interface BindOAuthFlowValidateReq {
  flowId: string;
  token: string;
}

export interface GetUserKycInfoReq {
  userId: number;
}

export interface GetUserKycInfoReply {
  userId: number;
  kycType: number;
  kycLevel: number;
  kycStatus: string;
  eddTag: string;
  remark: string;
}

export interface GetUserKycDetailInfoReq {
  userId: number;
}

export interface GetUserKycDetailInfoReply {
  userId: number;
  kycType: number;
  kycLevel: number;
  kycStatus: string;
  eddTag: string;
  nextStep: string;
  detailInfo: KycDetailInfo | undefined;
}

export interface KycDetailInfo {
  firstName: string;
  middleName: string;
  lastName: string;
  gender: string;
  dob: string;
  country: string;
  state: string;
  city: string;
  address: string;
  preferredAddress: string;
  alternativeAddress: string;
  postalCode: string;
  idType: string;
  idNumber: string;
  idExpiredDate: string;
  kycVendor: string;
  remark: string;
  applyTimes: number;
  email: string;
}

export interface GetKycAccessTokenReq {
  userId: number;
}

export interface GetKycAccessTokenReply {
  token: string;
}

export interface UploadKycResultReq {
  userId: number;
  nextStep: string;
  reviewStatus: string;
}

export interface LogoutReq {
  userId: number;
  refreshToken: string;
}

export interface CloseAccountPreCheckReq {
  userId: number;
}

export interface CloseAccountPreCheckResp {
  canDelete: boolean;
  hasOrders: boolean;
}

export interface CloseAccountReq {
  userId: number;
  reason: string;
}

export interface GetUserLimitsReq {
  userId: number;
}

export interface GetUserLimitsResp {
  currency: string;
  depositDaily: string;
  depositMonthly: string;
  depositYearly: string;
  depositLifetime: string;
  withdrawDaily: string;
  withdrawMonthly: string;
  withdrawYearly: string;
  withdrawLifetime: string;
  transactionDaily: string;
  transactionWeekly: string;
  transactionMonthly: string;
}

export interface GetUserSavedWalletsReq {
  userId: number;
  offset: number;
  limit: number;
}

export interface GetUserSavedWalletsResp {
  count: number;
  list: SavedWallet[];
}

export interface SavedWallet {
  id: number;
  userId: number;
  networkType: string;
  address: string;
  name: string;
}

export interface UserAddSavedWalletReq {
  userId: number;
  name: string;
  address: string;
  networkType: string;
}

export interface UserDeleteSavedWalletReq {
  userId: number;
  id: number;
}

export interface UserUpdateSavedWalletReq {
  userId: number;
  id: number;
  name: string;
  address: string;
  networkType: string;
}

export interface BindInviterReq {
  userId: number;
  inviteCode: string;
}

function createBaseGetSupportCountriesResp(): GetSupportCountriesResp {
  return { count: 0, list: [] };
}

export const GetSupportCountriesResp: MessageFns<GetSupportCountriesResp> = {
  encode(message: GetSupportCountriesResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    for (const v of message.list) {
      MobileCodeItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSupportCountriesResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSupportCountriesResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.list.push(MobileCodeItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSupportCountriesResp {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => MobileCodeItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetSupportCountriesResp): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.list?.length) {
      obj.list = message.list.map((e) => MobileCodeItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetSupportCountriesResp>): GetSupportCountriesResp {
    return GetSupportCountriesResp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSupportCountriesResp>): GetSupportCountriesResp {
    const message = createBaseGetSupportCountriesResp();
    message.count = object.count ?? 0;
    message.list = object.list?.map((e) => MobileCodeItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMobileCodeItem(): MobileCodeItem {
  return { mobileCode: "", flag: "", countryCode: "", countryName: "" };
}

export const MobileCodeItem: MessageFns<MobileCodeItem> = {
  encode(message: MobileCodeItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mobileCode !== "") {
      writer.uint32(10).string(message.mobileCode);
    }
    if (message.flag !== "") {
      writer.uint32(18).string(message.flag);
    }
    if (message.countryCode !== "") {
      writer.uint32(26).string(message.countryCode);
    }
    if (message.countryName !== "") {
      writer.uint32(34).string(message.countryName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MobileCodeItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMobileCodeItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mobileCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.flag = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.countryName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MobileCodeItem {
    return {
      mobileCode: isSet(object.mobileCode) ? globalThis.String(object.mobileCode) : "",
      flag: isSet(object.flag) ? globalThis.String(object.flag) : "",
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      countryName: isSet(object.countryName) ? globalThis.String(object.countryName) : "",
    };
  },

  toJSON(message: MobileCodeItem): unknown {
    const obj: any = {};
    if (message.mobileCode !== "") {
      obj.mobileCode = message.mobileCode;
    }
    if (message.flag !== "") {
      obj.flag = message.flag;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.countryName !== "") {
      obj.countryName = message.countryName;
    }
    return obj;
  },

  create(base?: DeepPartial<MobileCodeItem>): MobileCodeItem {
    return MobileCodeItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MobileCodeItem>): MobileCodeItem {
    const message = createBaseMobileCodeItem();
    message.mobileCode = object.mobileCode ?? "";
    message.flag = object.flag ?? "";
    message.countryCode = object.countryCode ?? "";
    message.countryName = object.countryName ?? "";
    return message;
  },
};

function createBaseSignFlowCreateReq(): SignFlowCreateReq {
  return {
    signFlowType: "",
    mobileCode: "",
    mobileNumber: "",
    email: "",
    oauthPlatform: "",
    locale: "",
    clientType: "",
    ip: "",
    countryCode: "",
  };
}

export const SignFlowCreateReq: MessageFns<SignFlowCreateReq> = {
  encode(message: SignFlowCreateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signFlowType !== "") {
      writer.uint32(10).string(message.signFlowType);
    }
    if (message.mobileCode !== "") {
      writer.uint32(18).string(message.mobileCode);
    }
    if (message.mobileNumber !== "") {
      writer.uint32(26).string(message.mobileNumber);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.oauthPlatform !== "") {
      writer.uint32(42).string(message.oauthPlatform);
    }
    if (message.locale !== "") {
      writer.uint32(50).string(message.locale);
    }
    if (message.clientType !== "") {
      writer.uint32(58).string(message.clientType);
    }
    if (message.ip !== "") {
      writer.uint32(66).string(message.ip);
    }
    if (message.countryCode !== "") {
      writer.uint32(74).string(message.countryCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignFlowCreateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignFlowCreateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signFlowType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mobileCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mobileNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.oauthPlatform = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clientType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignFlowCreateReq {
    return {
      signFlowType: isSet(object.signFlowType) ? globalThis.String(object.signFlowType) : "",
      mobileCode: isSet(object.mobileCode) ? globalThis.String(object.mobileCode) : "",
      mobileNumber: isSet(object.mobileNumber) ? globalThis.String(object.mobileNumber) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      oauthPlatform: isSet(object.oauthPlatform) ? globalThis.String(object.oauthPlatform) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      clientType: isSet(object.clientType) ? globalThis.String(object.clientType) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
    };
  },

  toJSON(message: SignFlowCreateReq): unknown {
    const obj: any = {};
    if (message.signFlowType !== "") {
      obj.signFlowType = message.signFlowType;
    }
    if (message.mobileCode !== "") {
      obj.mobileCode = message.mobileCode;
    }
    if (message.mobileNumber !== "") {
      obj.mobileNumber = message.mobileNumber;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.oauthPlatform !== "") {
      obj.oauthPlatform = message.oauthPlatform;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.clientType !== "") {
      obj.clientType = message.clientType;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    return obj;
  },

  create(base?: DeepPartial<SignFlowCreateReq>): SignFlowCreateReq {
    return SignFlowCreateReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignFlowCreateReq>): SignFlowCreateReq {
    const message = createBaseSignFlowCreateReq();
    message.signFlowType = object.signFlowType ?? "";
    message.mobileCode = object.mobileCode ?? "";
    message.mobileNumber = object.mobileNumber ?? "";
    message.email = object.email ?? "";
    message.oauthPlatform = object.oauthPlatform ?? "";
    message.locale = object.locale ?? "";
    message.clientType = object.clientType ?? "";
    message.ip = object.ip ?? "";
    message.countryCode = object.countryCode ?? "";
    return message;
  },
};

function createBaseSignFlowCreateResp(): SignFlowCreateResp {
  return { flowId: "" };
}

export const SignFlowCreateResp: MessageFns<SignFlowCreateResp> = {
  encode(message: SignFlowCreateResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignFlowCreateResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignFlowCreateResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignFlowCreateResp {
    return { flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "" };
  },

  toJSON(message: SignFlowCreateResp): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    return obj;
  },

  create(base?: DeepPartial<SignFlowCreateResp>): SignFlowCreateResp {
    return SignFlowCreateResp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignFlowCreateResp>): SignFlowCreateResp {
    const message = createBaseSignFlowCreateResp();
    message.flowId = object.flowId ?? "";
    return message;
  },
};

function createBaseSignFlowSendReq(): SignFlowSendReq {
  return { flowId: "" };
}

export const SignFlowSendReq: MessageFns<SignFlowSendReq> = {
  encode(message: SignFlowSendReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignFlowSendReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignFlowSendReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignFlowSendReq {
    return { flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "" };
  },

  toJSON(message: SignFlowSendReq): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    return obj;
  },

  create(base?: DeepPartial<SignFlowSendReq>): SignFlowSendReq {
    return SignFlowSendReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignFlowSendReq>): SignFlowSendReq {
    const message = createBaseSignFlowSendReq();
    message.flowId = object.flowId ?? "";
    return message;
  },
};

function createBaseSignFlowValidateReq(): SignFlowValidateReq {
  return {
    flowId: "",
    data: "",
    userAgent: "",
    forterMobileUid: "",
    brand: "",
    deviceModel: "",
    osVersion: "",
    appBuild: 0,
    appVersion: "",
  };
}

export const SignFlowValidateReq: MessageFns<SignFlowValidateReq> = {
  encode(message: SignFlowValidateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    if (message.userAgent !== "") {
      writer.uint32(26).string(message.userAgent);
    }
    if (message.forterMobileUid !== "") {
      writer.uint32(34).string(message.forterMobileUid);
    }
    if (message.brand !== "") {
      writer.uint32(42).string(message.brand);
    }
    if (message.deviceModel !== "") {
      writer.uint32(50).string(message.deviceModel);
    }
    if (message.osVersion !== "") {
      writer.uint32(58).string(message.osVersion);
    }
    if (message.appBuild !== 0) {
      writer.uint32(64).int64(message.appBuild);
    }
    if (message.appVersion !== "") {
      writer.uint32(74).string(message.appVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignFlowValidateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignFlowValidateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.forterMobileUid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.brand = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deviceModel = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.osVersion = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.appBuild = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignFlowValidateReq {
    return {
      flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      forterMobileUid: isSet(object.forterMobileUid) ? globalThis.String(object.forterMobileUid) : "",
      brand: isSet(object.brand) ? globalThis.String(object.brand) : "",
      deviceModel: isSet(object.deviceModel) ? globalThis.String(object.deviceModel) : "",
      osVersion: isSet(object.osVersion) ? globalThis.String(object.osVersion) : "",
      appBuild: isSet(object.appBuild) ? globalThis.Number(object.appBuild) : 0,
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : "",
    };
  },

  toJSON(message: SignFlowValidateReq): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.forterMobileUid !== "") {
      obj.forterMobileUid = message.forterMobileUid;
    }
    if (message.brand !== "") {
      obj.brand = message.brand;
    }
    if (message.deviceModel !== "") {
      obj.deviceModel = message.deviceModel;
    }
    if (message.osVersion !== "") {
      obj.osVersion = message.osVersion;
    }
    if (message.appBuild !== 0) {
      obj.appBuild = Math.round(message.appBuild);
    }
    if (message.appVersion !== "") {
      obj.appVersion = message.appVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<SignFlowValidateReq>): SignFlowValidateReq {
    return SignFlowValidateReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignFlowValidateReq>): SignFlowValidateReq {
    const message = createBaseSignFlowValidateReq();
    message.flowId = object.flowId ?? "";
    message.data = object.data ?? "";
    message.userAgent = object.userAgent ?? "";
    message.forterMobileUid = object.forterMobileUid ?? "";
    message.brand = object.brand ?? "";
    message.deviceModel = object.deviceModel ?? "";
    message.osVersion = object.osVersion ?? "";
    message.appBuild = object.appBuild ?? 0;
    message.appVersion = object.appVersion ?? "";
    return message;
  },
};

function createBaseSignFlowValidateResp(): SignFlowValidateResp {
  return { refreshToken: "", accessToken: "", signup: false };
}

export const SignFlowValidateResp: MessageFns<SignFlowValidateResp> = {
  encode(message: SignFlowValidateResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.signup !== false) {
      writer.uint32(24).bool(message.signup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignFlowValidateResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignFlowValidateResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signup = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignFlowValidateResp {
    return {
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      signup: isSet(object.signup) ? globalThis.Boolean(object.signup) : false,
    };
  },

  toJSON(message: SignFlowValidateResp): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.signup !== false) {
      obj.signup = message.signup;
    }
    return obj;
  },

  create(base?: DeepPartial<SignFlowValidateResp>): SignFlowValidateResp {
    return SignFlowValidateResp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignFlowValidateResp>): SignFlowValidateResp {
    const message = createBaseSignFlowValidateResp();
    message.refreshToken = object.refreshToken ?? "";
    message.accessToken = object.accessToken ?? "";
    message.signup = object.signup ?? false;
    return message;
  },
};

function createBaseLoginByPasswordReq(): LoginByPasswordReq {
  return {
    mobileCode: "",
    mobileNumber: "",
    countryCode: "",
    email: "",
    locale: "",
    userAgent: "",
    clientType: "",
    ip: "",
    forterMobileUid: "",
    password: "",
  };
}

export const LoginByPasswordReq: MessageFns<LoginByPasswordReq> = {
  encode(message: LoginByPasswordReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mobileCode !== "") {
      writer.uint32(10).string(message.mobileCode);
    }
    if (message.mobileNumber !== "") {
      writer.uint32(18).string(message.mobileNumber);
    }
    if (message.countryCode !== "") {
      writer.uint32(26).string(message.countryCode);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.locale !== "") {
      writer.uint32(42).string(message.locale);
    }
    if (message.userAgent !== "") {
      writer.uint32(50).string(message.userAgent);
    }
    if (message.clientType !== "") {
      writer.uint32(58).string(message.clientType);
    }
    if (message.ip !== "") {
      writer.uint32(66).string(message.ip);
    }
    if (message.forterMobileUid !== "") {
      writer.uint32(74).string(message.forterMobileUid);
    }
    if (message.password !== "") {
      writer.uint32(82).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginByPasswordReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginByPasswordReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mobileCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mobileNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clientType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.forterMobileUid = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginByPasswordReq {
    return {
      mobileCode: isSet(object.mobileCode) ? globalThis.String(object.mobileCode) : "",
      mobileNumber: isSet(object.mobileNumber) ? globalThis.String(object.mobileNumber) : "",
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      clientType: isSet(object.clientType) ? globalThis.String(object.clientType) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      forterMobileUid: isSet(object.forterMobileUid) ? globalThis.String(object.forterMobileUid) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginByPasswordReq): unknown {
    const obj: any = {};
    if (message.mobileCode !== "") {
      obj.mobileCode = message.mobileCode;
    }
    if (message.mobileNumber !== "") {
      obj.mobileNumber = message.mobileNumber;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.clientType !== "") {
      obj.clientType = message.clientType;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.forterMobileUid !== "") {
      obj.forterMobileUid = message.forterMobileUid;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create(base?: DeepPartial<LoginByPasswordReq>): LoginByPasswordReq {
    return LoginByPasswordReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoginByPasswordReq>): LoginByPasswordReq {
    const message = createBaseLoginByPasswordReq();
    message.mobileCode = object.mobileCode ?? "";
    message.mobileNumber = object.mobileNumber ?? "";
    message.countryCode = object.countryCode ?? "";
    message.email = object.email ?? "";
    message.locale = object.locale ?? "";
    message.userAgent = object.userAgent ?? "";
    message.clientType = object.clientType ?? "";
    message.ip = object.ip ?? "";
    message.forterMobileUid = object.forterMobileUid ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginByPasswordResp(): LoginByPasswordResp {
  return { accessToken: "", refreshToken: "" };
}

export const LoginByPasswordResp: MessageFns<LoginByPasswordResp> = {
  encode(message: LoginByPasswordResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginByPasswordResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginByPasswordResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginByPasswordResp {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: LoginByPasswordResp): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create(base?: DeepPartial<LoginByPasswordResp>): LoginByPasswordResp {
    return LoginByPasswordResp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoginByPasswordResp>): LoginByPasswordResp {
    const message = createBaseLoginByPasswordResp();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseCheckAccessTokenReq(): CheckAccessTokenReq {
  return { accessToken: "" };
}

export const CheckAccessTokenReq: MessageFns<CheckAccessTokenReq> = {
  encode(message: CheckAccessTokenReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckAccessTokenReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckAccessTokenReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckAccessTokenReq {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "" };
  },

  toJSON(message: CheckAccessTokenReq): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckAccessTokenReq>): CheckAccessTokenReq {
    return CheckAccessTokenReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckAccessTokenReq>): CheckAccessTokenReq {
    const message = createBaseCheckAccessTokenReq();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseCheckAccessTokenReply(): CheckAccessTokenReply {
  return { userId: 0, ok: false };
}

export const CheckAccessTokenReply: MessageFns<CheckAccessTokenReply> = {
  encode(message: CheckAccessTokenReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.ok !== false) {
      writer.uint32(16).bool(message.ok);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckAccessTokenReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckAccessTokenReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ok = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckAccessTokenReply {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
    };
  },

  toJSON(message: CheckAccessTokenReply): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckAccessTokenReply>): CheckAccessTokenReply {
    return CheckAccessTokenReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckAccessTokenReply>): CheckAccessTokenReply {
    const message = createBaseCheckAccessTokenReply();
    message.userId = object.userId ?? 0;
    message.ok = object.ok ?? false;
    return message;
  },
};

function createBaseGetAccessTokenReq(): GetAccessTokenReq {
  return { refreshToken: "" };
}

export const GetAccessTokenReq: MessageFns<GetAccessTokenReq> = {
  encode(message: GetAccessTokenReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccessTokenReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccessTokenReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccessTokenReq {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: GetAccessTokenReq): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAccessTokenReq>): GetAccessTokenReq {
    return GetAccessTokenReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAccessTokenReq>): GetAccessTokenReq {
    const message = createBaseGetAccessTokenReq();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseGetAccessTokenReply(): GetAccessTokenReply {
  return { accessToken: "" };
}

export const GetAccessTokenReply: MessageFns<GetAccessTokenReply> = {
  encode(message: GetAccessTokenReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccessTokenReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccessTokenReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccessTokenReply {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "" };
  },

  toJSON(message: GetAccessTokenReply): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAccessTokenReply>): GetAccessTokenReply {
    return GetAccessTokenReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAccessTokenReply>): GetAccessTokenReply {
    const message = createBaseGetAccessTokenReply();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseGetUserInfoReq(): GetUserInfoReq {
  return { userId: 0, internalUserId: "", externalUserId: "" };
}

export const GetUserInfoReq: MessageFns<GetUserInfoReq> = {
  encode(message: GetUserInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.internalUserId !== "") {
      writer.uint32(18).string(message.internalUserId);
    }
    if (message.externalUserId !== "") {
      writer.uint32(26).string(message.externalUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.internalUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInfoReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      internalUserId: isSet(object.internalUserId) ? globalThis.String(object.internalUserId) : "",
      externalUserId: isSet(object.externalUserId) ? globalThis.String(object.externalUserId) : "",
    };
  },

  toJSON(message: GetUserInfoReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.internalUserId !== "") {
      obj.internalUserId = message.internalUserId;
    }
    if (message.externalUserId !== "") {
      obj.externalUserId = message.externalUserId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserInfoReq>): GetUserInfoReq {
    return GetUserInfoReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserInfoReq>): GetUserInfoReq {
    const message = createBaseGetUserInfoReq();
    message.userId = object.userId ?? 0;
    message.internalUserId = object.internalUserId ?? "";
    message.externalUserId = object.externalUserId ?? "";
    return message;
  },
};

function createBaseGetUserInfoReply(): GetUserInfoReply {
  return {
    userId: 0,
    status: 0,
    locale: "",
    username: "",
    nickname: "",
    avatar: "",
    fiatCurrency: "",
    password: false,
    internalUserId: "",
    externalUserId: "",
    dob: "",
    email: "",
    mobile: "",
    notificationOn: false,
    intercomHmacIos: "",
    intercomHmacAndroid: "",
    inviteCode: "",
  };
}

export const GetUserInfoReply: MessageFns<GetUserInfoReply> = {
  encode(message: GetUserInfoReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.locale !== "") {
      writer.uint32(26).string(message.locale);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.nickname !== "") {
      writer.uint32(42).string(message.nickname);
    }
    if (message.avatar !== "") {
      writer.uint32(50).string(message.avatar);
    }
    if (message.fiatCurrency !== "") {
      writer.uint32(58).string(message.fiatCurrency);
    }
    if (message.password !== false) {
      writer.uint32(64).bool(message.password);
    }
    if (message.internalUserId !== "") {
      writer.uint32(74).string(message.internalUserId);
    }
    if (message.externalUserId !== "") {
      writer.uint32(82).string(message.externalUserId);
    }
    if (message.dob !== "") {
      writer.uint32(90).string(message.dob);
    }
    if (message.email !== "") {
      writer.uint32(98).string(message.email);
    }
    if (message.mobile !== "") {
      writer.uint32(106).string(message.mobile);
    }
    if (message.notificationOn !== false) {
      writer.uint32(112).bool(message.notificationOn);
    }
    if (message.intercomHmacIos !== "") {
      writer.uint32(122).string(message.intercomHmacIos);
    }
    if (message.intercomHmacAndroid !== "") {
      writer.uint32(130).string(message.intercomHmacAndroid);
    }
    if (message.inviteCode !== "") {
      writer.uint32(138).string(message.inviteCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInfoReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fiatCurrency = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.password = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.internalUserId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.externalUserId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dob = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.mobile = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.notificationOn = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.intercomHmacIos = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.intercomHmacAndroid = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.inviteCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInfoReply {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      status: isSet(object.status) ? userStatusFromJSON(object.status) : 0,
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      fiatCurrency: isSet(object.fiatCurrency) ? globalThis.String(object.fiatCurrency) : "",
      password: isSet(object.password) ? globalThis.Boolean(object.password) : false,
      internalUserId: isSet(object.internalUserId) ? globalThis.String(object.internalUserId) : "",
      externalUserId: isSet(object.externalUserId) ? globalThis.String(object.externalUserId) : "",
      dob: isSet(object.dob) ? globalThis.String(object.dob) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      mobile: isSet(object.mobile) ? globalThis.String(object.mobile) : "",
      notificationOn: isSet(object.notificationOn) ? globalThis.Boolean(object.notificationOn) : false,
      intercomHmacIos: isSet(object.intercomHmacIos) ? globalThis.String(object.intercomHmacIos) : "",
      intercomHmacAndroid: isSet(object.intercomHmacAndroid) ? globalThis.String(object.intercomHmacAndroid) : "",
      inviteCode: isSet(object.inviteCode) ? globalThis.String(object.inviteCode) : "",
    };
  },

  toJSON(message: GetUserInfoReply): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.status !== 0) {
      obj.status = userStatusToJSON(message.status);
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.fiatCurrency !== "") {
      obj.fiatCurrency = message.fiatCurrency;
    }
    if (message.password !== false) {
      obj.password = message.password;
    }
    if (message.internalUserId !== "") {
      obj.internalUserId = message.internalUserId;
    }
    if (message.externalUserId !== "") {
      obj.externalUserId = message.externalUserId;
    }
    if (message.dob !== "") {
      obj.dob = message.dob;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.mobile !== "") {
      obj.mobile = message.mobile;
    }
    if (message.notificationOn !== false) {
      obj.notificationOn = message.notificationOn;
    }
    if (message.intercomHmacIos !== "") {
      obj.intercomHmacIos = message.intercomHmacIos;
    }
    if (message.intercomHmacAndroid !== "") {
      obj.intercomHmacAndroid = message.intercomHmacAndroid;
    }
    if (message.inviteCode !== "") {
      obj.inviteCode = message.inviteCode;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserInfoReply>): GetUserInfoReply {
    return GetUserInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserInfoReply>): GetUserInfoReply {
    const message = createBaseGetUserInfoReply();
    message.userId = object.userId ?? 0;
    message.status = object.status ?? 0;
    message.locale = object.locale ?? "";
    message.username = object.username ?? "";
    message.nickname = object.nickname ?? "";
    message.avatar = object.avatar ?? "";
    message.fiatCurrency = object.fiatCurrency ?? "";
    message.password = object.password ?? false;
    message.internalUserId = object.internalUserId ?? "";
    message.externalUserId = object.externalUserId ?? "";
    message.dob = object.dob ?? "";
    message.email = object.email ?? "";
    message.mobile = object.mobile ?? "";
    message.notificationOn = object.notificationOn ?? false;
    message.intercomHmacIos = object.intercomHmacIos ?? "";
    message.intercomHmacAndroid = object.intercomHmacAndroid ?? "";
    message.inviteCode = object.inviteCode ?? "";
    return message;
  },
};

function createBaseQueryUserInfoReq(): QueryUserInfoReq {
  return { userIds: [] };
}

export const QueryUserInfoReq: MessageFns<QueryUserInfoReq> = {
  encode(message: QueryUserInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.userIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.userIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserInfoReq {
    return {
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: QueryUserInfoReq): unknown {
    const obj: any = {};
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUserInfoReq>): QueryUserInfoReq {
    return QueryUserInfoReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUserInfoReq>): QueryUserInfoReq {
    const message = createBaseQueryUserInfoReq();
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryUserInfoReply(): QueryUserInfoReply {
  return { list: [] };
}

export const QueryUserInfoReply: MessageFns<QueryUserInfoReply> = {
  encode(message: QueryUserInfoReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.list) {
      GetUserInfoReply.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserInfoReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.list.push(GetUserInfoReply.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserInfoReply {
    return {
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => GetUserInfoReply.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryUserInfoReply): unknown {
    const obj: any = {};
    if (message.list?.length) {
      obj.list = message.list.map((e) => GetUserInfoReply.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUserInfoReply>): QueryUserInfoReply {
    return QueryUserInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUserInfoReply>): QueryUserInfoReply {
    const message = createBaseQueryUserInfoReply();
    message.list = object.list?.map((e) => GetUserInfoReply.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetUserMobileReq(): GetUserMobileReq {
  return { userId: 0 };
}

export const GetUserMobileReq: MessageFns<GetUserMobileReq> = {
  encode(message: GetUserMobileReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserMobileReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserMobileReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserMobileReq {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: GetUserMobileReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserMobileReq>): GetUserMobileReq {
    return GetUserMobileReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserMobileReq>): GetUserMobileReq {
    const message = createBaseGetUserMobileReq();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseGetUserMobileReply(): GetUserMobileReply {
  return { userId: 0, mobileCode: "", mobileNumber: "" };
}

export const GetUserMobileReply: MessageFns<GetUserMobileReply> = {
  encode(message: GetUserMobileReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.mobileCode !== "") {
      writer.uint32(18).string(message.mobileCode);
    }
    if (message.mobileNumber !== "") {
      writer.uint32(26).string(message.mobileNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserMobileReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserMobileReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mobileCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mobileNumber = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserMobileReply {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      mobileCode: isSet(object.mobileCode) ? globalThis.String(object.mobileCode) : "",
      mobileNumber: isSet(object.mobileNumber) ? globalThis.String(object.mobileNumber) : "",
    };
  },

  toJSON(message: GetUserMobileReply): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.mobileCode !== "") {
      obj.mobileCode = message.mobileCode;
    }
    if (message.mobileNumber !== "") {
      obj.mobileNumber = message.mobileNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserMobileReply>): GetUserMobileReply {
    return GetUserMobileReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserMobileReply>): GetUserMobileReply {
    const message = createBaseGetUserMobileReply();
    message.userId = object.userId ?? 0;
    message.mobileCode = object.mobileCode ?? "";
    message.mobileNumber = object.mobileNumber ?? "";
    return message;
  },
};

function createBaseGetUserEmailReq(): GetUserEmailReq {
  return { userId: 0 };
}

export const GetUserEmailReq: MessageFns<GetUserEmailReq> = {
  encode(message: GetUserEmailReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserEmailReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserEmailReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserEmailReq {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: GetUserEmailReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserEmailReq>): GetUserEmailReq {
    return GetUserEmailReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserEmailReq>): GetUserEmailReq {
    const message = createBaseGetUserEmailReq();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseGetUserEmailReply(): GetUserEmailReply {
  return { userId: 0, email: "" };
}

export const GetUserEmailReply: MessageFns<GetUserEmailReply> = {
  encode(message: GetUserEmailReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserEmailReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserEmailReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserEmailReply {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: GetUserEmailReply): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserEmailReply>): GetUserEmailReply {
    return GetUserEmailReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserEmailReply>): GetUserEmailReply {
    const message = createBaseGetUserEmailReply();
    message.userId = object.userId ?? 0;
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseCheckUsernameReq(): CheckUsernameReq {
  return { userId: 0, username: "" };
}

export const CheckUsernameReq: MessageFns<CheckUsernameReq> = {
  encode(message: CheckUsernameReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUsernameReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUsernameReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUsernameReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: CheckUsernameReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckUsernameReq>): CheckUsernameReq {
    return CheckUsernameReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckUsernameReq>): CheckUsernameReq {
    const message = createBaseCheckUsernameReq();
    message.userId = object.userId ?? 0;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseSetupUsernameReq(): SetupUsernameReq {
  return { userId: 0, username: "" };
}

export const SetupUsernameReq: MessageFns<SetupUsernameReq> = {
  encode(message: SetupUsernameReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupUsernameReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupUsernameReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupUsernameReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: SetupUsernameReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<SetupUsernameReq>): SetupUsernameReq {
    return SetupUsernameReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetupUsernameReq>): SetupUsernameReq {
    const message = createBaseSetupUsernameReq();
    message.userId = object.userId ?? 0;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseSetupNicknameReq(): SetupNicknameReq {
  return { userId: 0, nickname: "" };
}

export const SetupNicknameReq: MessageFns<SetupNicknameReq> = {
  encode(message: SetupNicknameReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.nickname !== "") {
      writer.uint32(18).string(message.nickname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupNicknameReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupNicknameReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupNicknameReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
    };
  },

  toJSON(message: SetupNicknameReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    return obj;
  },

  create(base?: DeepPartial<SetupNicknameReq>): SetupNicknameReq {
    return SetupNicknameReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetupNicknameReq>): SetupNicknameReq {
    const message = createBaseSetupNicknameReq();
    message.userId = object.userId ?? 0;
    message.nickname = object.nickname ?? "";
    return message;
  },
};

function createBaseSetupDobReq(): SetupDobReq {
  return { userId: 0, dob: "" };
}

export const SetupDobReq: MessageFns<SetupDobReq> = {
  encode(message: SetupDobReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.dob !== "") {
      writer.uint32(18).string(message.dob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupDobReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupDobReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dob = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupDobReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      dob: isSet(object.dob) ? globalThis.String(object.dob) : "",
    };
  },

  toJSON(message: SetupDobReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.dob !== "") {
      obj.dob = message.dob;
    }
    return obj;
  },

  create(base?: DeepPartial<SetupDobReq>): SetupDobReq {
    return SetupDobReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetupDobReq>): SetupDobReq {
    const message = createBaseSetupDobReq();
    message.userId = object.userId ?? 0;
    message.dob = object.dob ?? "";
    return message;
  },
};

function createBaseSetupAvatarReq(): SetupAvatarReq {
  return { userId: 0, avatar: "" };
}

export const SetupAvatarReq: MessageFns<SetupAvatarReq> = {
  encode(message: SetupAvatarReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.avatar !== "") {
      writer.uint32(18).string(message.avatar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupAvatarReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupAvatarReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupAvatarReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: SetupAvatarReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create(base?: DeepPartial<SetupAvatarReq>): SetupAvatarReq {
    return SetupAvatarReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetupAvatarReq>): SetupAvatarReq {
    const message = createBaseSetupAvatarReq();
    message.userId = object.userId ?? 0;
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseUpdateFiatCurrencyReq(): UpdateFiatCurrencyReq {
  return { userId: 0, fiatCurrency: "" };
}

export const UpdateFiatCurrencyReq: MessageFns<UpdateFiatCurrencyReq> = {
  encode(message: UpdateFiatCurrencyReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.fiatCurrency !== "") {
      writer.uint32(18).string(message.fiatCurrency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFiatCurrencyReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFiatCurrencyReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fiatCurrency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFiatCurrencyReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      fiatCurrency: isSet(object.fiatCurrency) ? globalThis.String(object.fiatCurrency) : "",
    };
  },

  toJSON(message: UpdateFiatCurrencyReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.fiatCurrency !== "") {
      obj.fiatCurrency = message.fiatCurrency;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFiatCurrencyReq>): UpdateFiatCurrencyReq {
    return UpdateFiatCurrencyReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFiatCurrencyReq>): UpdateFiatCurrencyReq {
    const message = createBaseUpdateFiatCurrencyReq();
    message.userId = object.userId ?? 0;
    message.fiatCurrency = object.fiatCurrency ?? "";
    return message;
  },
};

function createBaseUpdateNotificationOnReq(): UpdateNotificationOnReq {
  return { userId: 0, notificationOn: false };
}

export const UpdateNotificationOnReq: MessageFns<UpdateNotificationOnReq> = {
  encode(message: UpdateNotificationOnReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.notificationOn !== false) {
      writer.uint32(16).bool(message.notificationOn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNotificationOnReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNotificationOnReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.notificationOn = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNotificationOnReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      notificationOn: isSet(object.notificationOn) ? globalThis.Boolean(object.notificationOn) : false,
    };
  },

  toJSON(message: UpdateNotificationOnReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.notificationOn !== false) {
      obj.notificationOn = message.notificationOn;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNotificationOnReq>): UpdateNotificationOnReq {
    return UpdateNotificationOnReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNotificationOnReq>): UpdateNotificationOnReq {
    const message = createBaseUpdateNotificationOnReq();
    message.userId = object.userId ?? 0;
    message.notificationOn = object.notificationOn ?? false;
    return message;
  },
};

function createBaseSetupPasswordReq(): SetupPasswordReq {
  return { userId: 0, oldPassword: "", newPassword: "" };
}

export const SetupPasswordReq: MessageFns<SetupPasswordReq> = {
  encode(message: SetupPasswordReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.oldPassword !== "") {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupPasswordReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupPasswordReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupPasswordReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: SetupPasswordReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create(base?: DeepPartial<SetupPasswordReq>): SetupPasswordReq {
    return SetupPasswordReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetupPasswordReq>): SetupPasswordReq {
    const message = createBaseSetupPasswordReq();
    message.userId = object.userId ?? 0;
    message.oldPassword = object.oldPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseBindEmailFlowCreateReq(): BindEmailFlowCreateReq {
  return { userId: 0, email: "" };
}

export const BindEmailFlowCreateReq: MessageFns<BindEmailFlowCreateReq> = {
  encode(message: BindEmailFlowCreateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindEmailFlowCreateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindEmailFlowCreateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindEmailFlowCreateReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: BindEmailFlowCreateReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<BindEmailFlowCreateReq>): BindEmailFlowCreateReq {
    return BindEmailFlowCreateReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindEmailFlowCreateReq>): BindEmailFlowCreateReq {
    const message = createBaseBindEmailFlowCreateReq();
    message.userId = object.userId ?? 0;
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseBindEmailFlowCreateReply(): BindEmailFlowCreateReply {
  return { flowId: "" };
}

export const BindEmailFlowCreateReply: MessageFns<BindEmailFlowCreateReply> = {
  encode(message: BindEmailFlowCreateReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindEmailFlowCreateReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindEmailFlowCreateReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindEmailFlowCreateReply {
    return { flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "" };
  },

  toJSON(message: BindEmailFlowCreateReply): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    return obj;
  },

  create(base?: DeepPartial<BindEmailFlowCreateReply>): BindEmailFlowCreateReply {
    return BindEmailFlowCreateReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindEmailFlowCreateReply>): BindEmailFlowCreateReply {
    const message = createBaseBindEmailFlowCreateReply();
    message.flowId = object.flowId ?? "";
    return message;
  },
};

function createBaseBindEmailFlowSendReq(): BindEmailFlowSendReq {
  return { flowId: "" };
}

export const BindEmailFlowSendReq: MessageFns<BindEmailFlowSendReq> = {
  encode(message: BindEmailFlowSendReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindEmailFlowSendReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindEmailFlowSendReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindEmailFlowSendReq {
    return { flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "" };
  },

  toJSON(message: BindEmailFlowSendReq): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    return obj;
  },

  create(base?: DeepPartial<BindEmailFlowSendReq>): BindEmailFlowSendReq {
    return BindEmailFlowSendReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindEmailFlowSendReq>): BindEmailFlowSendReq {
    const message = createBaseBindEmailFlowSendReq();
    message.flowId = object.flowId ?? "";
    return message;
  },
};

function createBaseBindEmailFlowValidateReq(): BindEmailFlowValidateReq {
  return { flowId: "", code: "" };
}

export const BindEmailFlowValidateReq: MessageFns<BindEmailFlowValidateReq> = {
  encode(message: BindEmailFlowValidateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindEmailFlowValidateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindEmailFlowValidateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindEmailFlowValidateReq {
    return {
      flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: BindEmailFlowValidateReq): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<BindEmailFlowValidateReq>): BindEmailFlowValidateReq {
    return BindEmailFlowValidateReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindEmailFlowValidateReq>): BindEmailFlowValidateReq {
    const message = createBaseBindEmailFlowValidateReq();
    message.flowId = object.flowId ?? "";
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseBindOAuthFlowCreateReq(): BindOAuthFlowCreateReq {
  return { userId: 0, platform: "" };
}

export const BindOAuthFlowCreateReq: MessageFns<BindOAuthFlowCreateReq> = {
  encode(message: BindOAuthFlowCreateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.platform !== "") {
      writer.uint32(18).string(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindOAuthFlowCreateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindOAuthFlowCreateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindOAuthFlowCreateReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
    };
  },

  toJSON(message: BindOAuthFlowCreateReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    return obj;
  },

  create(base?: DeepPartial<BindOAuthFlowCreateReq>): BindOAuthFlowCreateReq {
    return BindOAuthFlowCreateReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindOAuthFlowCreateReq>): BindOAuthFlowCreateReq {
    const message = createBaseBindOAuthFlowCreateReq();
    message.userId = object.userId ?? 0;
    message.platform = object.platform ?? "";
    return message;
  },
};

function createBaseBindOAuthFlowCreateReply(): BindOAuthFlowCreateReply {
  return { flowId: "" };
}

export const BindOAuthFlowCreateReply: MessageFns<BindOAuthFlowCreateReply> = {
  encode(message: BindOAuthFlowCreateReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindOAuthFlowCreateReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindOAuthFlowCreateReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindOAuthFlowCreateReply {
    return { flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "" };
  },

  toJSON(message: BindOAuthFlowCreateReply): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    return obj;
  },

  create(base?: DeepPartial<BindOAuthFlowCreateReply>): BindOAuthFlowCreateReply {
    return BindOAuthFlowCreateReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindOAuthFlowCreateReply>): BindOAuthFlowCreateReply {
    const message = createBaseBindOAuthFlowCreateReply();
    message.flowId = object.flowId ?? "";
    return message;
  },
};

function createBaseBindOAuthFlowValidateReq(): BindOAuthFlowValidateReq {
  return { flowId: "", token: "" };
}

export const BindOAuthFlowValidateReq: MessageFns<BindOAuthFlowValidateReq> = {
  encode(message: BindOAuthFlowValidateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowId !== "") {
      writer.uint32(10).string(message.flowId);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindOAuthFlowValidateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindOAuthFlowValidateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindOAuthFlowValidateReq {
    return {
      flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: BindOAuthFlowValidateReq): unknown {
    const obj: any = {};
    if (message.flowId !== "") {
      obj.flowId = message.flowId;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create(base?: DeepPartial<BindOAuthFlowValidateReq>): BindOAuthFlowValidateReq {
    return BindOAuthFlowValidateReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindOAuthFlowValidateReq>): BindOAuthFlowValidateReq {
    const message = createBaseBindOAuthFlowValidateReq();
    message.flowId = object.flowId ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseGetUserKycInfoReq(): GetUserKycInfoReq {
  return { userId: 0 };
}

export const GetUserKycInfoReq: MessageFns<GetUserKycInfoReq> = {
  encode(message: GetUserKycInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserKycInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserKycInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserKycInfoReq {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: GetUserKycInfoReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserKycInfoReq>): GetUserKycInfoReq {
    return GetUserKycInfoReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserKycInfoReq>): GetUserKycInfoReq {
    const message = createBaseGetUserKycInfoReq();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseGetUserKycInfoReply(): GetUserKycInfoReply {
  return { userId: 0, kycType: 0, kycLevel: 0, kycStatus: "", eddTag: "", remark: "" };
}

export const GetUserKycInfoReply: MessageFns<GetUserKycInfoReply> = {
  encode(message: GetUserKycInfoReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.kycType !== 0) {
      writer.uint32(16).uint64(message.kycType);
    }
    if (message.kycLevel !== 0) {
      writer.uint32(24).uint32(message.kycLevel);
    }
    if (message.kycStatus !== "") {
      writer.uint32(34).string(message.kycStatus);
    }
    if (message.eddTag !== "") {
      writer.uint32(42).string(message.eddTag);
    }
    if (message.remark !== "") {
      writer.uint32(50).string(message.remark);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserKycInfoReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserKycInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kycType = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kycLevel = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kycStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eddTag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.remark = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserKycInfoReply {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      kycType: isSet(object.kycType) ? globalThis.Number(object.kycType) : 0,
      kycLevel: isSet(object.kycLevel) ? globalThis.Number(object.kycLevel) : 0,
      kycStatus: isSet(object.kycStatus) ? globalThis.String(object.kycStatus) : "",
      eddTag: isSet(object.eddTag) ? globalThis.String(object.eddTag) : "",
      remark: isSet(object.remark) ? globalThis.String(object.remark) : "",
    };
  },

  toJSON(message: GetUserKycInfoReply): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.kycType !== 0) {
      obj.kycType = Math.round(message.kycType);
    }
    if (message.kycLevel !== 0) {
      obj.kycLevel = Math.round(message.kycLevel);
    }
    if (message.kycStatus !== "") {
      obj.kycStatus = message.kycStatus;
    }
    if (message.eddTag !== "") {
      obj.eddTag = message.eddTag;
    }
    if (message.remark !== "") {
      obj.remark = message.remark;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserKycInfoReply>): GetUserKycInfoReply {
    return GetUserKycInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserKycInfoReply>): GetUserKycInfoReply {
    const message = createBaseGetUserKycInfoReply();
    message.userId = object.userId ?? 0;
    message.kycType = object.kycType ?? 0;
    message.kycLevel = object.kycLevel ?? 0;
    message.kycStatus = object.kycStatus ?? "";
    message.eddTag = object.eddTag ?? "";
    message.remark = object.remark ?? "";
    return message;
  },
};

function createBaseGetUserKycDetailInfoReq(): GetUserKycDetailInfoReq {
  return { userId: 0 };
}

export const GetUserKycDetailInfoReq: MessageFns<GetUserKycDetailInfoReq> = {
  encode(message: GetUserKycDetailInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserKycDetailInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserKycDetailInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserKycDetailInfoReq {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: GetUserKycDetailInfoReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserKycDetailInfoReq>): GetUserKycDetailInfoReq {
    return GetUserKycDetailInfoReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserKycDetailInfoReq>): GetUserKycDetailInfoReq {
    const message = createBaseGetUserKycDetailInfoReq();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseGetUserKycDetailInfoReply(): GetUserKycDetailInfoReply {
  return { userId: 0, kycType: 0, kycLevel: 0, kycStatus: "", eddTag: "", nextStep: "", detailInfo: undefined };
}

export const GetUserKycDetailInfoReply: MessageFns<GetUserKycDetailInfoReply> = {
  encode(message: GetUserKycDetailInfoReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.kycType !== 0) {
      writer.uint32(16).uint64(message.kycType);
    }
    if (message.kycLevel !== 0) {
      writer.uint32(24).uint32(message.kycLevel);
    }
    if (message.kycStatus !== "") {
      writer.uint32(34).string(message.kycStatus);
    }
    if (message.eddTag !== "") {
      writer.uint32(42).string(message.eddTag);
    }
    if (message.nextStep !== "") {
      writer.uint32(50).string(message.nextStep);
    }
    if (message.detailInfo !== undefined) {
      KycDetailInfo.encode(message.detailInfo, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserKycDetailInfoReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserKycDetailInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kycType = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kycLevel = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kycStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eddTag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nextStep = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.detailInfo = KycDetailInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserKycDetailInfoReply {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      kycType: isSet(object.kycType) ? globalThis.Number(object.kycType) : 0,
      kycLevel: isSet(object.kycLevel) ? globalThis.Number(object.kycLevel) : 0,
      kycStatus: isSet(object.kycStatus) ? globalThis.String(object.kycStatus) : "",
      eddTag: isSet(object.eddTag) ? globalThis.String(object.eddTag) : "",
      nextStep: isSet(object.nextStep) ? globalThis.String(object.nextStep) : "",
      detailInfo: isSet(object.detailInfo) ? KycDetailInfo.fromJSON(object.detailInfo) : undefined,
    };
  },

  toJSON(message: GetUserKycDetailInfoReply): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.kycType !== 0) {
      obj.kycType = Math.round(message.kycType);
    }
    if (message.kycLevel !== 0) {
      obj.kycLevel = Math.round(message.kycLevel);
    }
    if (message.kycStatus !== "") {
      obj.kycStatus = message.kycStatus;
    }
    if (message.eddTag !== "") {
      obj.eddTag = message.eddTag;
    }
    if (message.nextStep !== "") {
      obj.nextStep = message.nextStep;
    }
    if (message.detailInfo !== undefined) {
      obj.detailInfo = KycDetailInfo.toJSON(message.detailInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserKycDetailInfoReply>): GetUserKycDetailInfoReply {
    return GetUserKycDetailInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserKycDetailInfoReply>): GetUserKycDetailInfoReply {
    const message = createBaseGetUserKycDetailInfoReply();
    message.userId = object.userId ?? 0;
    message.kycType = object.kycType ?? 0;
    message.kycLevel = object.kycLevel ?? 0;
    message.kycStatus = object.kycStatus ?? "";
    message.eddTag = object.eddTag ?? "";
    message.nextStep = object.nextStep ?? "";
    message.detailInfo = (object.detailInfo !== undefined && object.detailInfo !== null)
      ? KycDetailInfo.fromPartial(object.detailInfo)
      : undefined;
    return message;
  },
};

function createBaseKycDetailInfo(): KycDetailInfo {
  return {
    firstName: "",
    middleName: "",
    lastName: "",
    gender: "",
    dob: "",
    country: "",
    state: "",
    city: "",
    address: "",
    preferredAddress: "",
    alternativeAddress: "",
    postalCode: "",
    idType: "",
    idNumber: "",
    idExpiredDate: "",
    kycVendor: "",
    remark: "",
    applyTimes: 0,
    email: "",
  };
}

export const KycDetailInfo: MessageFns<KycDetailInfo> = {
  encode(message: KycDetailInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstName !== "") {
      writer.uint32(10).string(message.firstName);
    }
    if (message.middleName !== "") {
      writer.uint32(18).string(message.middleName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    if (message.gender !== "") {
      writer.uint32(34).string(message.gender);
    }
    if (message.dob !== "") {
      writer.uint32(42).string(message.dob);
    }
    if (message.country !== "") {
      writer.uint32(50).string(message.country);
    }
    if (message.state !== "") {
      writer.uint32(58).string(message.state);
    }
    if (message.city !== "") {
      writer.uint32(66).string(message.city);
    }
    if (message.address !== "") {
      writer.uint32(74).string(message.address);
    }
    if (message.preferredAddress !== "") {
      writer.uint32(82).string(message.preferredAddress);
    }
    if (message.alternativeAddress !== "") {
      writer.uint32(90).string(message.alternativeAddress);
    }
    if (message.postalCode !== "") {
      writer.uint32(98).string(message.postalCode);
    }
    if (message.idType !== "") {
      writer.uint32(106).string(message.idType);
    }
    if (message.idNumber !== "") {
      writer.uint32(114).string(message.idNumber);
    }
    if (message.idExpiredDate !== "") {
      writer.uint32(122).string(message.idExpiredDate);
    }
    if (message.kycVendor !== "") {
      writer.uint32(130).string(message.kycVendor);
    }
    if (message.remark !== "") {
      writer.uint32(138).string(message.remark);
    }
    if (message.applyTimes !== 0) {
      writer.uint32(144).uint64(message.applyTimes);
    }
    if (message.email !== "") {
      writer.uint32(154).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KycDetailInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKycDetailInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.middleName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dob = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.preferredAddress = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.alternativeAddress = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.idType = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.idNumber = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.idExpiredDate = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.kycVendor = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.remark = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.applyTimes = longToNumber(reader.uint64());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KycDetailInfo {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      middleName: isSet(object.middleName) ? globalThis.String(object.middleName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      dob: isSet(object.dob) ? globalThis.String(object.dob) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      preferredAddress: isSet(object.preferredAddress) ? globalThis.String(object.preferredAddress) : "",
      alternativeAddress: isSet(object.alternativeAddress) ? globalThis.String(object.alternativeAddress) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
      idType: isSet(object.idType) ? globalThis.String(object.idType) : "",
      idNumber: isSet(object.idNumber) ? globalThis.String(object.idNumber) : "",
      idExpiredDate: isSet(object.idExpiredDate) ? globalThis.String(object.idExpiredDate) : "",
      kycVendor: isSet(object.kycVendor) ? globalThis.String(object.kycVendor) : "",
      remark: isSet(object.remark) ? globalThis.String(object.remark) : "",
      applyTimes: isSet(object.applyTimes) ? globalThis.Number(object.applyTimes) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: KycDetailInfo): unknown {
    const obj: any = {};
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.middleName !== "") {
      obj.middleName = message.middleName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.dob !== "") {
      obj.dob = message.dob;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.preferredAddress !== "") {
      obj.preferredAddress = message.preferredAddress;
    }
    if (message.alternativeAddress !== "") {
      obj.alternativeAddress = message.alternativeAddress;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.idType !== "") {
      obj.idType = message.idType;
    }
    if (message.idNumber !== "") {
      obj.idNumber = message.idNumber;
    }
    if (message.idExpiredDate !== "") {
      obj.idExpiredDate = message.idExpiredDate;
    }
    if (message.kycVendor !== "") {
      obj.kycVendor = message.kycVendor;
    }
    if (message.remark !== "") {
      obj.remark = message.remark;
    }
    if (message.applyTimes !== 0) {
      obj.applyTimes = Math.round(message.applyTimes);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<KycDetailInfo>): KycDetailInfo {
    return KycDetailInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KycDetailInfo>): KycDetailInfo {
    const message = createBaseKycDetailInfo();
    message.firstName = object.firstName ?? "";
    message.middleName = object.middleName ?? "";
    message.lastName = object.lastName ?? "";
    message.gender = object.gender ?? "";
    message.dob = object.dob ?? "";
    message.country = object.country ?? "";
    message.state = object.state ?? "";
    message.city = object.city ?? "";
    message.address = object.address ?? "";
    message.preferredAddress = object.preferredAddress ?? "";
    message.alternativeAddress = object.alternativeAddress ?? "";
    message.postalCode = object.postalCode ?? "";
    message.idType = object.idType ?? "";
    message.idNumber = object.idNumber ?? "";
    message.idExpiredDate = object.idExpiredDate ?? "";
    message.kycVendor = object.kycVendor ?? "";
    message.remark = object.remark ?? "";
    message.applyTimes = object.applyTimes ?? 0;
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseGetKycAccessTokenReq(): GetKycAccessTokenReq {
  return { userId: 0 };
}

export const GetKycAccessTokenReq: MessageFns<GetKycAccessTokenReq> = {
  encode(message: GetKycAccessTokenReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKycAccessTokenReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKycAccessTokenReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKycAccessTokenReq {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: GetKycAccessTokenReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetKycAccessTokenReq>): GetKycAccessTokenReq {
    return GetKycAccessTokenReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetKycAccessTokenReq>): GetKycAccessTokenReq {
    const message = createBaseGetKycAccessTokenReq();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseGetKycAccessTokenReply(): GetKycAccessTokenReply {
  return { token: "" };
}

export const GetKycAccessTokenReply: MessageFns<GetKycAccessTokenReply> = {
  encode(message: GetKycAccessTokenReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKycAccessTokenReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKycAccessTokenReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKycAccessTokenReply {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: GetKycAccessTokenReply): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create(base?: DeepPartial<GetKycAccessTokenReply>): GetKycAccessTokenReply {
    return GetKycAccessTokenReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetKycAccessTokenReply>): GetKycAccessTokenReply {
    const message = createBaseGetKycAccessTokenReply();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseUploadKycResultReq(): UploadKycResultReq {
  return { userId: 0, nextStep: "", reviewStatus: "" };
}

export const UploadKycResultReq: MessageFns<UploadKycResultReq> = {
  encode(message: UploadKycResultReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.nextStep !== "") {
      writer.uint32(18).string(message.nextStep);
    }
    if (message.reviewStatus !== "") {
      writer.uint32(26).string(message.reviewStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadKycResultReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadKycResultReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextStep = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reviewStatus = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadKycResultReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      nextStep: isSet(object.nextStep) ? globalThis.String(object.nextStep) : "",
      reviewStatus: isSet(object.reviewStatus) ? globalThis.String(object.reviewStatus) : "",
    };
  },

  toJSON(message: UploadKycResultReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.nextStep !== "") {
      obj.nextStep = message.nextStep;
    }
    if (message.reviewStatus !== "") {
      obj.reviewStatus = message.reviewStatus;
    }
    return obj;
  },

  create(base?: DeepPartial<UploadKycResultReq>): UploadKycResultReq {
    return UploadKycResultReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadKycResultReq>): UploadKycResultReq {
    const message = createBaseUploadKycResultReq();
    message.userId = object.userId ?? 0;
    message.nextStep = object.nextStep ?? "";
    message.reviewStatus = object.reviewStatus ?? "";
    return message;
  },
};

function createBaseLogoutReq(): LogoutReq {
  return { userId: 0, refreshToken: "" };
}

export const LogoutReq: MessageFns<LogoutReq> = {
  encode(message: LogoutReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: LogoutReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create(base?: DeepPartial<LogoutReq>): LogoutReq {
    return LogoutReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogoutReq>): LogoutReq {
    const message = createBaseLogoutReq();
    message.userId = object.userId ?? 0;
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseCloseAccountPreCheckReq(): CloseAccountPreCheckReq {
  return { userId: 0 };
}

export const CloseAccountPreCheckReq: MessageFns<CloseAccountPreCheckReq> = {
  encode(message: CloseAccountPreCheckReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseAccountPreCheckReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseAccountPreCheckReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseAccountPreCheckReq {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: CloseAccountPreCheckReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<CloseAccountPreCheckReq>): CloseAccountPreCheckReq {
    return CloseAccountPreCheckReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloseAccountPreCheckReq>): CloseAccountPreCheckReq {
    const message = createBaseCloseAccountPreCheckReq();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseCloseAccountPreCheckResp(): CloseAccountPreCheckResp {
  return { canDelete: false, hasOrders: false };
}

export const CloseAccountPreCheckResp: MessageFns<CloseAccountPreCheckResp> = {
  encode(message: CloseAccountPreCheckResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canDelete !== false) {
      writer.uint32(8).bool(message.canDelete);
    }
    if (message.hasOrders !== false) {
      writer.uint32(16).bool(message.hasOrders);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseAccountPreCheckResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseAccountPreCheckResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.canDelete = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasOrders = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseAccountPreCheckResp {
    return {
      canDelete: isSet(object.canDelete) ? globalThis.Boolean(object.canDelete) : false,
      hasOrders: isSet(object.hasOrders) ? globalThis.Boolean(object.hasOrders) : false,
    };
  },

  toJSON(message: CloseAccountPreCheckResp): unknown {
    const obj: any = {};
    if (message.canDelete !== false) {
      obj.canDelete = message.canDelete;
    }
    if (message.hasOrders !== false) {
      obj.hasOrders = message.hasOrders;
    }
    return obj;
  },

  create(base?: DeepPartial<CloseAccountPreCheckResp>): CloseAccountPreCheckResp {
    return CloseAccountPreCheckResp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloseAccountPreCheckResp>): CloseAccountPreCheckResp {
    const message = createBaseCloseAccountPreCheckResp();
    message.canDelete = object.canDelete ?? false;
    message.hasOrders = object.hasOrders ?? false;
    return message;
  },
};

function createBaseCloseAccountReq(): CloseAccountReq {
  return { userId: 0, reason: "" };
}

export const CloseAccountReq: MessageFns<CloseAccountReq> = {
  encode(message: CloseAccountReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseAccountReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseAccountReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseAccountReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CloseAccountReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<CloseAccountReq>): CloseAccountReq {
    return CloseAccountReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloseAccountReq>): CloseAccountReq {
    const message = createBaseCloseAccountReq();
    message.userId = object.userId ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseGetUserLimitsReq(): GetUserLimitsReq {
  return { userId: 0 };
}

export const GetUserLimitsReq: MessageFns<GetUserLimitsReq> = {
  encode(message: GetUserLimitsReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserLimitsReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserLimitsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserLimitsReq {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: GetUserLimitsReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserLimitsReq>): GetUserLimitsReq {
    return GetUserLimitsReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserLimitsReq>): GetUserLimitsReq {
    const message = createBaseGetUserLimitsReq();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseGetUserLimitsResp(): GetUserLimitsResp {
  return {
    currency: "",
    depositDaily: "",
    depositMonthly: "",
    depositYearly: "",
    depositLifetime: "",
    withdrawDaily: "",
    withdrawMonthly: "",
    withdrawYearly: "",
    withdrawLifetime: "",
    transactionDaily: "",
    transactionWeekly: "",
    transactionMonthly: "",
  };
}

export const GetUserLimitsResp: MessageFns<GetUserLimitsResp> = {
  encode(message: GetUserLimitsResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.depositDaily !== "") {
      writer.uint32(18).string(message.depositDaily);
    }
    if (message.depositMonthly !== "") {
      writer.uint32(26).string(message.depositMonthly);
    }
    if (message.depositYearly !== "") {
      writer.uint32(34).string(message.depositYearly);
    }
    if (message.depositLifetime !== "") {
      writer.uint32(42).string(message.depositLifetime);
    }
    if (message.withdrawDaily !== "") {
      writer.uint32(50).string(message.withdrawDaily);
    }
    if (message.withdrawMonthly !== "") {
      writer.uint32(58).string(message.withdrawMonthly);
    }
    if (message.withdrawYearly !== "") {
      writer.uint32(66).string(message.withdrawYearly);
    }
    if (message.withdrawLifetime !== "") {
      writer.uint32(74).string(message.withdrawLifetime);
    }
    if (message.transactionDaily !== "") {
      writer.uint32(82).string(message.transactionDaily);
    }
    if (message.transactionWeekly !== "") {
      writer.uint32(90).string(message.transactionWeekly);
    }
    if (message.transactionMonthly !== "") {
      writer.uint32(98).string(message.transactionMonthly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserLimitsResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserLimitsResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.depositDaily = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.depositMonthly = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.depositYearly = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.depositLifetime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.withdrawDaily = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.withdrawMonthly = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.withdrawYearly = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.withdrawLifetime = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.transactionDaily = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.transactionWeekly = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.transactionMonthly = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserLimitsResp {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      depositDaily: isSet(object.depositDaily) ? globalThis.String(object.depositDaily) : "",
      depositMonthly: isSet(object.depositMonthly) ? globalThis.String(object.depositMonthly) : "",
      depositYearly: isSet(object.depositYearly) ? globalThis.String(object.depositYearly) : "",
      depositLifetime: isSet(object.depositLifetime) ? globalThis.String(object.depositLifetime) : "",
      withdrawDaily: isSet(object.withdrawDaily) ? globalThis.String(object.withdrawDaily) : "",
      withdrawMonthly: isSet(object.withdrawMonthly) ? globalThis.String(object.withdrawMonthly) : "",
      withdrawYearly: isSet(object.withdrawYearly) ? globalThis.String(object.withdrawYearly) : "",
      withdrawLifetime: isSet(object.withdrawLifetime) ? globalThis.String(object.withdrawLifetime) : "",
      transactionDaily: isSet(object.transactionDaily) ? globalThis.String(object.transactionDaily) : "",
      transactionWeekly: isSet(object.transactionWeekly) ? globalThis.String(object.transactionWeekly) : "",
      transactionMonthly: isSet(object.transactionMonthly) ? globalThis.String(object.transactionMonthly) : "",
    };
  },

  toJSON(message: GetUserLimitsResp): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.depositDaily !== "") {
      obj.depositDaily = message.depositDaily;
    }
    if (message.depositMonthly !== "") {
      obj.depositMonthly = message.depositMonthly;
    }
    if (message.depositYearly !== "") {
      obj.depositYearly = message.depositYearly;
    }
    if (message.depositLifetime !== "") {
      obj.depositLifetime = message.depositLifetime;
    }
    if (message.withdrawDaily !== "") {
      obj.withdrawDaily = message.withdrawDaily;
    }
    if (message.withdrawMonthly !== "") {
      obj.withdrawMonthly = message.withdrawMonthly;
    }
    if (message.withdrawYearly !== "") {
      obj.withdrawYearly = message.withdrawYearly;
    }
    if (message.withdrawLifetime !== "") {
      obj.withdrawLifetime = message.withdrawLifetime;
    }
    if (message.transactionDaily !== "") {
      obj.transactionDaily = message.transactionDaily;
    }
    if (message.transactionWeekly !== "") {
      obj.transactionWeekly = message.transactionWeekly;
    }
    if (message.transactionMonthly !== "") {
      obj.transactionMonthly = message.transactionMonthly;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserLimitsResp>): GetUserLimitsResp {
    return GetUserLimitsResp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserLimitsResp>): GetUserLimitsResp {
    const message = createBaseGetUserLimitsResp();
    message.currency = object.currency ?? "";
    message.depositDaily = object.depositDaily ?? "";
    message.depositMonthly = object.depositMonthly ?? "";
    message.depositYearly = object.depositYearly ?? "";
    message.depositLifetime = object.depositLifetime ?? "";
    message.withdrawDaily = object.withdrawDaily ?? "";
    message.withdrawMonthly = object.withdrawMonthly ?? "";
    message.withdrawYearly = object.withdrawYearly ?? "";
    message.withdrawLifetime = object.withdrawLifetime ?? "";
    message.transactionDaily = object.transactionDaily ?? "";
    message.transactionWeekly = object.transactionWeekly ?? "";
    message.transactionMonthly = object.transactionMonthly ?? "";
    return message;
  },
};

function createBaseGetUserSavedWalletsReq(): GetUserSavedWalletsReq {
  return { userId: 0, offset: 0, limit: 0 };
}

export const GetUserSavedWalletsReq: MessageFns<GetUserSavedWalletsReq> = {
  encode(message: GetUserSavedWalletsReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int64(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserSavedWalletsReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserSavedWalletsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserSavedWalletsReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GetUserSavedWalletsReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserSavedWalletsReq>): GetUserSavedWalletsReq {
    return GetUserSavedWalletsReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserSavedWalletsReq>): GetUserSavedWalletsReq {
    const message = createBaseGetUserSavedWalletsReq();
    message.userId = object.userId ?? 0;
    message.offset = object.offset ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGetUserSavedWalletsResp(): GetUserSavedWalletsResp {
  return { count: 0, list: [] };
}

export const GetUserSavedWalletsResp: MessageFns<GetUserSavedWalletsResp> = {
  encode(message: GetUserSavedWalletsResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    for (const v of message.list) {
      SavedWallet.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserSavedWalletsResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserSavedWalletsResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.list.push(SavedWallet.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserSavedWalletsResp {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => SavedWallet.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetUserSavedWalletsResp): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.list?.length) {
      obj.list = message.list.map((e) => SavedWallet.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserSavedWalletsResp>): GetUserSavedWalletsResp {
    return GetUserSavedWalletsResp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserSavedWalletsResp>): GetUserSavedWalletsResp {
    const message = createBaseGetUserSavedWalletsResp();
    message.count = object.count ?? 0;
    message.list = object.list?.map((e) => SavedWallet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSavedWallet(): SavedWallet {
  return { id: 0, userId: 0, networkType: "", address: "", name: "" };
}

export const SavedWallet: MessageFns<SavedWallet> = {
  encode(message: SavedWallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).uint64(message.userId);
    }
    if (message.networkType !== "") {
      writer.uint32(26).string(message.networkType);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SavedWallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSavedWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.networkType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SavedWallet {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      networkType: isSet(object.networkType) ? globalThis.String(object.networkType) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SavedWallet): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.networkType !== "") {
      obj.networkType = message.networkType;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SavedWallet>): SavedWallet {
    return SavedWallet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SavedWallet>): SavedWallet {
    const message = createBaseSavedWallet();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? 0;
    message.networkType = object.networkType ?? "";
    message.address = object.address ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUserAddSavedWalletReq(): UserAddSavedWalletReq {
  return { userId: 0, name: "", address: "", networkType: "" };
}

export const UserAddSavedWalletReq: MessageFns<UserAddSavedWalletReq> = {
  encode(message: UserAddSavedWalletReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.networkType !== "") {
      writer.uint32(34).string(message.networkType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserAddSavedWalletReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserAddSavedWalletReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.networkType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserAddSavedWalletReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      networkType: isSet(object.networkType) ? globalThis.String(object.networkType) : "",
    };
  },

  toJSON(message: UserAddSavedWalletReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.networkType !== "") {
      obj.networkType = message.networkType;
    }
    return obj;
  },

  create(base?: DeepPartial<UserAddSavedWalletReq>): UserAddSavedWalletReq {
    return UserAddSavedWalletReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserAddSavedWalletReq>): UserAddSavedWalletReq {
    const message = createBaseUserAddSavedWalletReq();
    message.userId = object.userId ?? 0;
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.networkType = object.networkType ?? "";
    return message;
  },
};

function createBaseUserDeleteSavedWalletReq(): UserDeleteSavedWalletReq {
  return { userId: 0, id: 0 };
}

export const UserDeleteSavedWalletReq: MessageFns<UserDeleteSavedWalletReq> = {
  encode(message: UserDeleteSavedWalletReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDeleteSavedWalletReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDeleteSavedWalletReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDeleteSavedWalletReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: UserDeleteSavedWalletReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<UserDeleteSavedWalletReq>): UserDeleteSavedWalletReq {
    return UserDeleteSavedWalletReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserDeleteSavedWalletReq>): UserDeleteSavedWalletReq {
    const message = createBaseUserDeleteSavedWalletReq();
    message.userId = object.userId ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseUserUpdateSavedWalletReq(): UserUpdateSavedWalletReq {
  return { userId: 0, id: 0, name: "", address: "", networkType: "" };
}

export const UserUpdateSavedWalletReq: MessageFns<UserUpdateSavedWalletReq> = {
  encode(message: UserUpdateSavedWalletReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    if (message.networkType !== "") {
      writer.uint32(42).string(message.networkType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserUpdateSavedWalletReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserUpdateSavedWalletReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.networkType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserUpdateSavedWalletReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      networkType: isSet(object.networkType) ? globalThis.String(object.networkType) : "",
    };
  },

  toJSON(message: UserUpdateSavedWalletReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.networkType !== "") {
      obj.networkType = message.networkType;
    }
    return obj;
  },

  create(base?: DeepPartial<UserUpdateSavedWalletReq>): UserUpdateSavedWalletReq {
    return UserUpdateSavedWalletReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserUpdateSavedWalletReq>): UserUpdateSavedWalletReq {
    const message = createBaseUserUpdateSavedWalletReq();
    message.userId = object.userId ?? 0;
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.networkType = object.networkType ?? "";
    return message;
  },
};

function createBaseBindInviterReq(): BindInviterReq {
  return { userId: 0, inviteCode: "" };
}

export const BindInviterReq: MessageFns<BindInviterReq> = {
  encode(message: BindInviterReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.inviteCode !== "") {
      writer.uint32(18).string(message.inviteCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindInviterReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindInviterReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviteCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindInviterReq {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      inviteCode: isSet(object.inviteCode) ? globalThis.String(object.inviteCode) : "",
    };
  },

  toJSON(message: BindInviterReq): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.inviteCode !== "") {
      obj.inviteCode = message.inviteCode;
    }
    return obj;
  },

  create(base?: DeepPartial<BindInviterReq>): BindInviterReq {
    return BindInviterReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindInviterReq>): BindInviterReq {
    const message = createBaseBindInviterReq();
    message.userId = object.userId ?? 0;
    message.inviteCode = object.inviteCode ?? "";
    return message;
  },
};

export type UserDefinition = typeof UserDefinition;
export const UserDefinition = {
  name: "User",
  fullName: "user.service.v1.User",
  methods: {
    /** 注册登录流程第一步(主要是选择登录注册的方式) */
    signFlowCreate: {
      name: "SignFlowCreate",
      requestType: SignFlowCreateReq,
      requestStream: false,
      responseType: SignFlowCreateResp,
      responseStream: false,
      options: {},
    },
    /** 注册登录流程第一步(发送对应的验证码SMS/Email) */
    signFlowSend: {
      name: "SignFlowSend",
      requestType: SignFlowSendReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 注册登录流程第三步(验证验证码&登录注册账号) */
    signFlowValidate: {
      name: "SignFlowValidate",
      requestType: SignFlowValidateReq,
      requestStream: false,
      responseType: SignFlowValidateResp,
      responseStream: false,
      options: {},
    },
    /** Login */
    loginByPassword: {
      name: "LoginByPassword",
      requestType: LoginByPasswordReq,
      requestStream: false,
      responseType: LoginByPasswordResp,
      responseStream: false,
      options: {},
    },
    /** 检查是否登录 */
    checkAccessToken: {
      name: "CheckAccessToken",
      requestType: CheckAccessTokenReq,
      requestStream: false,
      responseType: CheckAccessTokenReply,
      responseStream: false,
      options: {},
    },
    /** 刷新登录Token时长 */
    getAccessToken: {
      name: "GetAccessToken",
      requestType: GetAccessTokenReq,
      requestStream: false,
      responseType: GetAccessTokenReply,
      responseStream: false,
      options: {},
    },
    /** 获取用户简单信息 */
    getUserInfo: {
      name: "GetUserInfo",
      requestType: GetUserInfoReq,
      requestStream: false,
      responseType: GetUserInfoReply,
      responseStream: false,
      options: {},
    },
    /** 批量查询指定用户信息 */
    queryUserInfo: {
      name: "QueryUserInfo",
      requestType: QueryUserInfoReq,
      requestStream: false,
      responseType: QueryUserInfoReply,
      responseStream: false,
      options: {},
    },
    /** 获取用户手机号 */
    getUserMobile: {
      name: "GetUserMobile",
      requestType: GetUserMobileReq,
      requestStream: false,
      responseType: GetUserMobileReply,
      responseStream: false,
      options: {},
    },
    /** 获取用户邮箱 */
    getUserEmail: {
      name: "GetUserEmail",
      requestType: GetUserEmailReq,
      requestStream: false,
      responseType: GetUserEmailReply,
      responseStream: false,
      options: {},
    },
    /** 检查Username是否存在 */
    checkUsername: {
      name: "CheckUsername",
      requestType: CheckUsernameReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 设置Username */
    setupUsername: {
      name: "SetupUsername",
      requestType: SetupUsernameReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 设置昵称 */
    setupNickname: {
      name: "SetupNickname",
      requestType: SetupNicknameReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 设置DOB */
    setupDob: {
      name: "SetupDob",
      requestType: SetupDobReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 设置头像 */
    setupAvatar: {
      name: "SetupAvatar",
      requestType: SetupAvatarReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 更新FiatCurrency */
    updateFiatCurrency: {
      name: "UpdateFiatCurrency",
      requestType: UpdateFiatCurrencyReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 更新NotificationOn */
    updateNotificationOn: {
      name: "UpdateNotificationOn",
      requestType: UpdateNotificationOnReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 设置账号密码(旧密码) */
    setupPassword: {
      name: "SetupPassword",
      requestType: SetupPasswordReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 绑定邮箱第一步(创建Flow) */
    bindEmailFlowCreate: {
      name: "BindEmailFlowCreate",
      requestType: BindEmailFlowCreateReq,
      requestStream: false,
      responseType: BindEmailFlowCreateReply,
      responseStream: false,
      options: {},
    },
    /** 绑定邮箱第二步(发送邮箱验证码) */
    bindEmailFlowSend: {
      name: "BindEmailFlowSend",
      requestType: BindEmailFlowSendReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 绑定邮箱第三步(验证验证码) */
    bindEmailFlowValidate: {
      name: "BindEmailFlowValidate",
      requestType: BindEmailFlowValidateReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 绑定OAuth第一步(创建Flow) */
    bindOAuthFlowCreate: {
      name: "BindOAuthFlowCreate",
      requestType: BindOAuthFlowCreateReq,
      requestStream: false,
      responseType: BindOAuthFlowCreateReply,
      responseStream: false,
      options: {},
    },
    /** 绑定OAuth第二步(验证Token并绑定) */
    bindOAuthFlowValidate: {
      name: "BindOAuthFlowValidate",
      requestType: BindOAuthFlowValidateReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 获取用户KYC简单信息 */
    getUserKycInfo: {
      name: "GetUserKycInfo",
      requestType: GetUserKycInfoReq,
      requestStream: false,
      responseType: GetUserKycInfoReply,
      responseStream: false,
      options: {},
    },
    /** 获取用户KYC详细信息 */
    getUserKycDetailInfo: {
      name: "GetUserKycDetailInfo",
      requestType: GetUserKycDetailInfoReq,
      requestStream: false,
      responseType: GetUserKycDetailInfoReply,
      responseStream: false,
      options: {},
    },
    /** 获取KYC初始化用的AccessToken */
    getKycAccessToken: {
      name: "GetKycAccessToken",
      requestType: GetKycAccessTokenReq,
      requestStream: false,
      responseType: GetKycAccessTokenReply,
      responseStream: false,
      options: {},
    },
    /** 上传KYC结果 */
    uploadKycResult: {
      name: "UploadKycResult",
      requestType: UploadKycResultReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 更新用户KYC信息(Task用) */
    updateKycDetailPending: {
      name: "UpdateKycDetailPending",
      requestType: Empty,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    updateKycDetailAll: {
      name: "UpdateKycDetailAll",
      requestType: Empty,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 退出登录 */
    logout: {
      name: "Logout",
      requestType: LogoutReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 注销账户预检查 */
    closeAccountPreCheck: {
      name: "CloseAccountPreCheck",
      requestType: CloseAccountPreCheckReq,
      requestStream: false,
      responseType: CloseAccountPreCheckResp,
      responseStream: false,
      options: {},
    },
    /** 注销账户 */
    closeAccount: {
      name: "CloseAccount",
      requestType: CloseAccountReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 获取用户的UserLimits */
    getUserLimits: {
      name: "GetUserLimits",
      requestType: GetUserLimitsReq,
      requestStream: false,
      responseType: GetUserLimitsResp,
      responseStream: false,
      options: {},
    },
    /** 获取用户SavedWallet列表 */
    getUserSavedWallets: {
      name: "GetUserSavedWallets",
      requestType: GetUserSavedWalletsReq,
      requestStream: false,
      responseType: GetUserSavedWalletsResp,
      responseStream: false,
      options: {},
    },
    /** 用户新增SavedWallet */
    userAddSavedWallet: {
      name: "UserAddSavedWallet",
      requestType: UserAddSavedWalletReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 用户删除SavedWallet */
    userDeleteSavedWallet: {
      name: "UserDeleteSavedWallet",
      requestType: UserDeleteSavedWalletReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 用户编辑SavedWallet */
    userUpdateSavedWallet: {
      name: "UserUpdateSavedWallet",
      requestType: UserUpdateSavedWalletReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 绑定邀请人 */
    bindInviter: {
      name: "BindInviter",
      requestType: BindInviterReq,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** 获取支持的国家和手机区号 */
    getSupportCountries: {
      name: "GetSupportCountries",
      requestType: Empty,
      requestStream: false,
      responseType: GetSupportCountriesResp,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface UserServiceImplementation<CallContextExt = {}> {
  /** 注册登录流程第一步(主要是选择登录注册的方式) */
  signFlowCreate(
    request: SignFlowCreateReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignFlowCreateResp>>;
  /** 注册登录流程第一步(发送对应的验证码SMS/Email) */
  signFlowSend(request: SignFlowSendReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 注册登录流程第三步(验证验证码&登录注册账号) */
  signFlowValidate(
    request: SignFlowValidateReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignFlowValidateResp>>;
  /** Login */
  loginByPassword(
    request: LoginByPasswordReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LoginByPasswordResp>>;
  /** 检查是否登录 */
  checkAccessToken(
    request: CheckAccessTokenReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CheckAccessTokenReply>>;
  /** 刷新登录Token时长 */
  getAccessToken(
    request: GetAccessTokenReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetAccessTokenReply>>;
  /** 获取用户简单信息 */
  getUserInfo(request: GetUserInfoReq, context: CallContext & CallContextExt): Promise<DeepPartial<GetUserInfoReply>>;
  /** 批量查询指定用户信息 */
  queryUserInfo(
    request: QueryUserInfoReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryUserInfoReply>>;
  /** 获取用户手机号 */
  getUserMobile(
    request: GetUserMobileReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetUserMobileReply>>;
  /** 获取用户邮箱 */
  getUserEmail(
    request: GetUserEmailReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetUserEmailReply>>;
  /** 检查Username是否存在 */
  checkUsername(request: CheckUsernameReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 设置Username */
  setupUsername(request: SetupUsernameReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 设置昵称 */
  setupNickname(request: SetupNicknameReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 设置DOB */
  setupDob(request: SetupDobReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 设置头像 */
  setupAvatar(request: SetupAvatarReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 更新FiatCurrency */
  updateFiatCurrency(
    request: UpdateFiatCurrencyReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** 更新NotificationOn */
  updateNotificationOn(
    request: UpdateNotificationOnReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** 设置账号密码(旧密码) */
  setupPassword(request: SetupPasswordReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 绑定邮箱第一步(创建Flow) */
  bindEmailFlowCreate(
    request: BindEmailFlowCreateReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BindEmailFlowCreateReply>>;
  /** 绑定邮箱第二步(发送邮箱验证码) */
  bindEmailFlowSend(request: BindEmailFlowSendReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 绑定邮箱第三步(验证验证码) */
  bindEmailFlowValidate(
    request: BindEmailFlowValidateReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** 绑定OAuth第一步(创建Flow) */
  bindOAuthFlowCreate(
    request: BindOAuthFlowCreateReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BindOAuthFlowCreateReply>>;
  /** 绑定OAuth第二步(验证Token并绑定) */
  bindOAuthFlowValidate(
    request: BindOAuthFlowValidateReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** 获取用户KYC简单信息 */
  getUserKycInfo(
    request: GetUserKycInfoReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetUserKycInfoReply>>;
  /** 获取用户KYC详细信息 */
  getUserKycDetailInfo(
    request: GetUserKycDetailInfoReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetUserKycDetailInfoReply>>;
  /** 获取KYC初始化用的AccessToken */
  getKycAccessToken(
    request: GetKycAccessTokenReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetKycAccessTokenReply>>;
  /** 上传KYC结果 */
  uploadKycResult(request: UploadKycResultReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 更新用户KYC信息(Task用) */
  updateKycDetailPending(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  updateKycDetailAll(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 退出登录 */
  logout(request: LogoutReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 注销账户预检查 */
  closeAccountPreCheck(
    request: CloseAccountPreCheckReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CloseAccountPreCheckResp>>;
  /** 注销账户 */
  closeAccount(request: CloseAccountReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 获取用户的UserLimits */
  getUserLimits(
    request: GetUserLimitsReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetUserLimitsResp>>;
  /** 获取用户SavedWallet列表 */
  getUserSavedWallets(
    request: GetUserSavedWalletsReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetUserSavedWalletsResp>>;
  /** 用户新增SavedWallet */
  userAddSavedWallet(
    request: UserAddSavedWalletReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** 用户删除SavedWallet */
  userDeleteSavedWallet(
    request: UserDeleteSavedWalletReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** 用户编辑SavedWallet */
  userUpdateSavedWallet(
    request: UserUpdateSavedWalletReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** 绑定邀请人 */
  bindInviter(request: BindInviterReq, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** 获取支持的国家和手机区号 */
  getSupportCountries(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSupportCountriesResp>>;
}

export interface UserClient<CallOptionsExt = {}> {
  /** 注册登录流程第一步(主要是选择登录注册的方式) */
  signFlowCreate(
    request: DeepPartial<SignFlowCreateReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignFlowCreateResp>;
  /** 注册登录流程第一步(发送对应的验证码SMS/Email) */
  signFlowSend(request: DeepPartial<SignFlowSendReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 注册登录流程第三步(验证验证码&登录注册账号) */
  signFlowValidate(
    request: DeepPartial<SignFlowValidateReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignFlowValidateResp>;
  /** Login */
  loginByPassword(
    request: DeepPartial<LoginByPasswordReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LoginByPasswordResp>;
  /** 检查是否登录 */
  checkAccessToken(
    request: DeepPartial<CheckAccessTokenReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CheckAccessTokenReply>;
  /** 刷新登录Token时长 */
  getAccessToken(
    request: DeepPartial<GetAccessTokenReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetAccessTokenReply>;
  /** 获取用户简单信息 */
  getUserInfo(request: DeepPartial<GetUserInfoReq>, options?: CallOptions & CallOptionsExt): Promise<GetUserInfoReply>;
  /** 批量查询指定用户信息 */
  queryUserInfo(
    request: DeepPartial<QueryUserInfoReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryUserInfoReply>;
  /** 获取用户手机号 */
  getUserMobile(
    request: DeepPartial<GetUserMobileReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetUserMobileReply>;
  /** 获取用户邮箱 */
  getUserEmail(
    request: DeepPartial<GetUserEmailReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetUserEmailReply>;
  /** 检查Username是否存在 */
  checkUsername(request: DeepPartial<CheckUsernameReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 设置Username */
  setupUsername(request: DeepPartial<SetupUsernameReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 设置昵称 */
  setupNickname(request: DeepPartial<SetupNicknameReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 设置DOB */
  setupDob(request: DeepPartial<SetupDobReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 设置头像 */
  setupAvatar(request: DeepPartial<SetupAvatarReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 更新FiatCurrency */
  updateFiatCurrency(
    request: DeepPartial<UpdateFiatCurrencyReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** 更新NotificationOn */
  updateNotificationOn(
    request: DeepPartial<UpdateNotificationOnReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** 设置账号密码(旧密码) */
  setupPassword(request: DeepPartial<SetupPasswordReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 绑定邮箱第一步(创建Flow) */
  bindEmailFlowCreate(
    request: DeepPartial<BindEmailFlowCreateReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BindEmailFlowCreateReply>;
  /** 绑定邮箱第二步(发送邮箱验证码) */
  bindEmailFlowSend(request: DeepPartial<BindEmailFlowSendReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 绑定邮箱第三步(验证验证码) */
  bindEmailFlowValidate(
    request: DeepPartial<BindEmailFlowValidateReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** 绑定OAuth第一步(创建Flow) */
  bindOAuthFlowCreate(
    request: DeepPartial<BindOAuthFlowCreateReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BindOAuthFlowCreateReply>;
  /** 绑定OAuth第二步(验证Token并绑定) */
  bindOAuthFlowValidate(
    request: DeepPartial<BindOAuthFlowValidateReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** 获取用户KYC简单信息 */
  getUserKycInfo(
    request: DeepPartial<GetUserKycInfoReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetUserKycInfoReply>;
  /** 获取用户KYC详细信息 */
  getUserKycDetailInfo(
    request: DeepPartial<GetUserKycDetailInfoReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetUserKycDetailInfoReply>;
  /** 获取KYC初始化用的AccessToken */
  getKycAccessToken(
    request: DeepPartial<GetKycAccessTokenReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetKycAccessTokenReply>;
  /** 上传KYC结果 */
  uploadKycResult(request: DeepPartial<UploadKycResultReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 更新用户KYC信息(Task用) */
  updateKycDetailPending(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  updateKycDetailAll(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 退出登录 */
  logout(request: DeepPartial<LogoutReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 注销账户预检查 */
  closeAccountPreCheck(
    request: DeepPartial<CloseAccountPreCheckReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CloseAccountPreCheckResp>;
  /** 注销账户 */
  closeAccount(request: DeepPartial<CloseAccountReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 获取用户的UserLimits */
  getUserLimits(
    request: DeepPartial<GetUserLimitsReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetUserLimitsResp>;
  /** 获取用户SavedWallet列表 */
  getUserSavedWallets(
    request: DeepPartial<GetUserSavedWalletsReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetUserSavedWalletsResp>;
  /** 用户新增SavedWallet */
  userAddSavedWallet(
    request: DeepPartial<UserAddSavedWalletReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** 用户删除SavedWallet */
  userDeleteSavedWallet(
    request: DeepPartial<UserDeleteSavedWalletReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** 用户编辑SavedWallet */
  userUpdateSavedWallet(
    request: DeepPartial<UserUpdateSavedWalletReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** 绑定邀请人 */
  bindInviter(request: DeepPartial<BindInviterReq>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** 获取支持的国家和手机区号 */
  getSupportCountries(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSupportCountriesResp>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
