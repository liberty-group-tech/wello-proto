// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: wello-fiat-hub/admin/v1/admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Filter, OrderBy, Paging } from "../../shared/v1/misc";
import { Card, CardStats } from "../../shared/v1/payment_method";

export const protobufPackage = "admin.v1";

export interface WebhookEvent {
  id: string;
  source: string;
  sourceId: string;
  headers: { [key: string]: string };
  body: string;
  contentType: string;
  status: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface WebhookEvent_HeadersEntry {
  key: string;
  value: string;
}

export interface GetWebhookEventsReq {
  paging: Paging | undefined;
  filters: Filter[];
  orderBy: OrderBy[];
}

export interface GetWebhookEventsReply {
  total: number;
  skip: number;
  limit: number;
  events: WebhookEvent[];
}

export interface GetTransactionStatusLogsReq {
  id: string;
}

export interface TransactionStatusLog {
  id: number;
  transactionId: string;
  fromStatus: string;
  toStatus: string;
  fromStatusCode: number;
  toStatusCode: number;
  fromChannelStatus: string;
  toChannelStatus: string;
  fromChannelMessage: string;
  toChannelMessage: string;
  note: string;
  updatedBy: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface GetTransactionStatusLogsReply {
  logs: TransactionStatusLog[];
}

export interface MigrateCardTempReq {
  userIds: string[];
  dryRun?: boolean | undefined;
}

export interface MigrateCardTempReply {
  count: number;
}

export interface ReplayWebhookEventReq {
  webhookEventId: string;
  forward?: boolean | undefined;
}

export interface ReplayWebhookEventReply {
  newWebhookEventId: string;
  originalWebhookEventId: string;
  forwardCount: number;
}

export interface ReplayTransactionStatusEventReq {
  transactionId?: string | undefined;
}

export interface ReplayTransactionStatusEventReply {
  status: string;
}

export interface UpdateCardCardMetaReq {
  cardId: string;
  channelId: string;
}

export interface UpdateCardCardMetaReply {
  cardId: string;
  card: Card | undefined;
  stats: CardStats | undefined;
}

function createBaseWebhookEvent(): WebhookEvent {
  return {
    id: "",
    source: "",
    sourceId: "",
    headers: {},
    body: "",
    contentType: "",
    status: "",
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const WebhookEvent: MessageFns<WebhookEvent> = {
  encode(message: WebhookEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.sourceId !== "") {
      writer.uint32(26).string(message.sourceId);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      WebhookEvent_HeadersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.body !== "") {
      writer.uint32(42).string(message.body);
    }
    if (message.contentType !== "") {
      writer.uint32(50).string(message.contentType);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = WebhookEvent_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.headers[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: WebhookEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.sourceId !== "") {
      obj.sourceId = message.sourceId;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookEvent>): WebhookEvent {
    return WebhookEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookEvent>): WebhookEvent {
    const message = createBaseWebhookEvent();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.sourceId = object.sourceId ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? "";
    message.contentType = object.contentType ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseWebhookEvent_HeadersEntry(): WebhookEvent_HeadersEntry {
  return { key: "", value: "" };
}

export const WebhookEvent_HeadersEntry: MessageFns<WebhookEvent_HeadersEntry> = {
  encode(message: WebhookEvent_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookEvent_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookEvent_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookEvent_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WebhookEvent_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookEvent_HeadersEntry>): WebhookEvent_HeadersEntry {
    return WebhookEvent_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookEvent_HeadersEntry>): WebhookEvent_HeadersEntry {
    const message = createBaseWebhookEvent_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetWebhookEventsReq(): GetWebhookEventsReq {
  return { paging: undefined, filters: [], orderBy: [] };
}

export const GetWebhookEventsReq: MessageFns<GetWebhookEventsReq> = {
  encode(message: GetWebhookEventsReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(10).fork()).join();
    }
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.orderBy) {
      OrderBy.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWebhookEventsReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWebhookEventsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paging = Paging.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderBy.push(OrderBy.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWebhookEventsReq {
    return {
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
      orderBy: globalThis.Array.isArray(object?.orderBy) ? object.orderBy.map((e: any) => OrderBy.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetWebhookEventsReq): unknown {
    const obj: any = {};
    if (message.paging !== undefined) {
      obj.paging = Paging.toJSON(message.paging);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => OrderBy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetWebhookEventsReq>): GetWebhookEventsReq {
    return GetWebhookEventsReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWebhookEventsReq>): GetWebhookEventsReq {
    const message = createBaseGetWebhookEventsReq();
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    message.orderBy = object.orderBy?.map((e) => OrderBy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetWebhookEventsReply(): GetWebhookEventsReply {
  return { total: 0, skip: 0, limit: 0, events: [] };
}

export const GetWebhookEventsReply: MessageFns<GetWebhookEventsReply> = {
  encode(message: GetWebhookEventsReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int64(message.total);
    }
    if (message.skip !== 0) {
      writer.uint32(16).int64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int64(message.limit);
    }
    for (const v of message.events) {
      WebhookEvent.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWebhookEventsReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWebhookEventsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.skip = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.events.push(WebhookEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWebhookEventsReply {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      skip: isSet(object.skip) ? globalThis.Number(object.skip) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => WebhookEvent.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetWebhookEventsReply): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.skip !== 0) {
      obj.skip = Math.round(message.skip);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => WebhookEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetWebhookEventsReply>): GetWebhookEventsReply {
    return GetWebhookEventsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWebhookEventsReply>): GetWebhookEventsReply {
    const message = createBaseGetWebhookEventsReply();
    message.total = object.total ?? 0;
    message.skip = object.skip ?? 0;
    message.limit = object.limit ?? 0;
    message.events = object.events?.map((e) => WebhookEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTransactionStatusLogsReq(): GetTransactionStatusLogsReq {
  return { id: "" };
}

export const GetTransactionStatusLogsReq: MessageFns<GetTransactionStatusLogsReq> = {
  encode(message: GetTransactionStatusLogsReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionStatusLogsReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionStatusLogsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionStatusLogsReq {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetTransactionStatusLogsReq): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionStatusLogsReq>): GetTransactionStatusLogsReq {
    return GetTransactionStatusLogsReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionStatusLogsReq>): GetTransactionStatusLogsReq {
    const message = createBaseGetTransactionStatusLogsReq();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseTransactionStatusLog(): TransactionStatusLog {
  return {
    id: 0,
    transactionId: "",
    fromStatus: "",
    toStatus: "",
    fromStatusCode: 0,
    toStatusCode: 0,
    fromChannelStatus: "",
    toChannelStatus: "",
    fromChannelMessage: "",
    toChannelMessage: "",
    note: "",
    updatedBy: "",
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const TransactionStatusLog: MessageFns<TransactionStatusLog> = {
  encode(message: TransactionStatusLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.fromStatus !== "") {
      writer.uint32(26).string(message.fromStatus);
    }
    if (message.toStatus !== "") {
      writer.uint32(34).string(message.toStatus);
    }
    if (message.fromStatusCode !== 0) {
      writer.uint32(40).int32(message.fromStatusCode);
    }
    if (message.toStatusCode !== 0) {
      writer.uint32(48).int32(message.toStatusCode);
    }
    if (message.fromChannelStatus !== "") {
      writer.uint32(58).string(message.fromChannelStatus);
    }
    if (message.toChannelStatus !== "") {
      writer.uint32(66).string(message.toChannelStatus);
    }
    if (message.fromChannelMessage !== "") {
      writer.uint32(74).string(message.fromChannelMessage);
    }
    if (message.toChannelMessage !== "") {
      writer.uint32(82).string(message.toChannelMessage);
    }
    if (message.note !== "") {
      writer.uint32(90).string(message.note);
    }
    if (message.updatedBy !== "") {
      writer.uint32(98).string(message.updatedBy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(106).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionStatusLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionStatusLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromStatus = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fromStatusCode = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.toStatusCode = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fromChannelStatus = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.toChannelStatus = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.fromChannelMessage = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.toChannelMessage = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionStatusLog {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      fromStatus: isSet(object.fromStatus) ? globalThis.String(object.fromStatus) : "",
      toStatus: isSet(object.toStatus) ? globalThis.String(object.toStatus) : "",
      fromStatusCode: isSet(object.fromStatusCode) ? globalThis.Number(object.fromStatusCode) : 0,
      toStatusCode: isSet(object.toStatusCode) ? globalThis.Number(object.toStatusCode) : 0,
      fromChannelStatus: isSet(object.fromChannelStatus) ? globalThis.String(object.fromChannelStatus) : "",
      toChannelStatus: isSet(object.toChannelStatus) ? globalThis.String(object.toChannelStatus) : "",
      fromChannelMessage: isSet(object.fromChannelMessage) ? globalThis.String(object.fromChannelMessage) : "",
      toChannelMessage: isSet(object.toChannelMessage) ? globalThis.String(object.toChannelMessage) : "",
      note: isSet(object.note) ? globalThis.String(object.note) : "",
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: TransactionStatusLog): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.fromStatus !== "") {
      obj.fromStatus = message.fromStatus;
    }
    if (message.toStatus !== "") {
      obj.toStatus = message.toStatus;
    }
    if (message.fromStatusCode !== 0) {
      obj.fromStatusCode = Math.round(message.fromStatusCode);
    }
    if (message.toStatusCode !== 0) {
      obj.toStatusCode = Math.round(message.toStatusCode);
    }
    if (message.fromChannelStatus !== "") {
      obj.fromChannelStatus = message.fromChannelStatus;
    }
    if (message.toChannelStatus !== "") {
      obj.toChannelStatus = message.toChannelStatus;
    }
    if (message.fromChannelMessage !== "") {
      obj.fromChannelMessage = message.fromChannelMessage;
    }
    if (message.toChannelMessage !== "") {
      obj.toChannelMessage = message.toChannelMessage;
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionStatusLog>): TransactionStatusLog {
    return TransactionStatusLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionStatusLog>): TransactionStatusLog {
    const message = createBaseTransactionStatusLog();
    message.id = object.id ?? 0;
    message.transactionId = object.transactionId ?? "";
    message.fromStatus = object.fromStatus ?? "";
    message.toStatus = object.toStatus ?? "";
    message.fromStatusCode = object.fromStatusCode ?? 0;
    message.toStatusCode = object.toStatusCode ?? 0;
    message.fromChannelStatus = object.fromChannelStatus ?? "";
    message.toChannelStatus = object.toChannelStatus ?? "";
    message.fromChannelMessage = object.fromChannelMessage ?? "";
    message.toChannelMessage = object.toChannelMessage ?? "";
    message.note = object.note ?? "";
    message.updatedBy = object.updatedBy ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetTransactionStatusLogsReply(): GetTransactionStatusLogsReply {
  return { logs: [] };
}

export const GetTransactionStatusLogsReply: MessageFns<GetTransactionStatusLogsReply> = {
  encode(message: GetTransactionStatusLogsReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      TransactionStatusLog.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionStatusLogsReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionStatusLogsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(TransactionStatusLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionStatusLogsReply {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => TransactionStatusLog.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetTransactionStatusLogsReply): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => TransactionStatusLog.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionStatusLogsReply>): GetTransactionStatusLogsReply {
    return GetTransactionStatusLogsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionStatusLogsReply>): GetTransactionStatusLogsReply {
    const message = createBaseGetTransactionStatusLogsReply();
    message.logs = object.logs?.map((e) => TransactionStatusLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMigrateCardTempReq(): MigrateCardTempReq {
  return { userIds: [], dryRun: undefined };
}

export const MigrateCardTempReq: MessageFns<MigrateCardTempReq> = {
  encode(message: MigrateCardTempReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userIds) {
      writer.uint32(10).string(v!);
    }
    if (message.dryRun !== undefined) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrateCardTempReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrateCardTempReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrateCardTempReq {
    return {
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : undefined,
    };
  },

  toJSON(message: MigrateCardTempReq): unknown {
    const obj: any = {};
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.dryRun !== undefined) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create(base?: DeepPartial<MigrateCardTempReq>): MigrateCardTempReq {
    return MigrateCardTempReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrateCardTempReq>): MigrateCardTempReq {
    const message = createBaseMigrateCardTempReq();
    message.userIds = object.userIds?.map((e) => e) || [];
    message.dryRun = object.dryRun ?? undefined;
    return message;
  },
};

function createBaseMigrateCardTempReply(): MigrateCardTempReply {
  return { count: 0 };
}

export const MigrateCardTempReply: MessageFns<MigrateCardTempReply> = {
  encode(message: MigrateCardTempReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrateCardTempReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrateCardTempReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrateCardTempReply {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: MigrateCardTempReply): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<MigrateCardTempReply>): MigrateCardTempReply {
    return MigrateCardTempReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrateCardTempReply>): MigrateCardTempReply {
    const message = createBaseMigrateCardTempReply();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseReplayWebhookEventReq(): ReplayWebhookEventReq {
  return { webhookEventId: "", forward: undefined };
}

export const ReplayWebhookEventReq: MessageFns<ReplayWebhookEventReq> = {
  encode(message: ReplayWebhookEventReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.webhookEventId !== "") {
      writer.uint32(10).string(message.webhookEventId);
    }
    if (message.forward !== undefined) {
      writer.uint32(16).bool(message.forward);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayWebhookEventReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayWebhookEventReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.webhookEventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.forward = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayWebhookEventReq {
    return {
      webhookEventId: isSet(object.webhookEventId) ? globalThis.String(object.webhookEventId) : "",
      forward: isSet(object.forward) ? globalThis.Boolean(object.forward) : undefined,
    };
  },

  toJSON(message: ReplayWebhookEventReq): unknown {
    const obj: any = {};
    if (message.webhookEventId !== "") {
      obj.webhookEventId = message.webhookEventId;
    }
    if (message.forward !== undefined) {
      obj.forward = message.forward;
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayWebhookEventReq>): ReplayWebhookEventReq {
    return ReplayWebhookEventReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayWebhookEventReq>): ReplayWebhookEventReq {
    const message = createBaseReplayWebhookEventReq();
    message.webhookEventId = object.webhookEventId ?? "";
    message.forward = object.forward ?? undefined;
    return message;
  },
};

function createBaseReplayWebhookEventReply(): ReplayWebhookEventReply {
  return { newWebhookEventId: "", originalWebhookEventId: "", forwardCount: 0 };
}

export const ReplayWebhookEventReply: MessageFns<ReplayWebhookEventReply> = {
  encode(message: ReplayWebhookEventReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newWebhookEventId !== "") {
      writer.uint32(10).string(message.newWebhookEventId);
    }
    if (message.originalWebhookEventId !== "") {
      writer.uint32(18).string(message.originalWebhookEventId);
    }
    if (message.forwardCount !== 0) {
      writer.uint32(24).int32(message.forwardCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayWebhookEventReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayWebhookEventReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newWebhookEventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originalWebhookEventId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.forwardCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayWebhookEventReply {
    return {
      newWebhookEventId: isSet(object.newWebhookEventId) ? globalThis.String(object.newWebhookEventId) : "",
      originalWebhookEventId: isSet(object.originalWebhookEventId)
        ? globalThis.String(object.originalWebhookEventId)
        : "",
      forwardCount: isSet(object.forwardCount) ? globalThis.Number(object.forwardCount) : 0,
    };
  },

  toJSON(message: ReplayWebhookEventReply): unknown {
    const obj: any = {};
    if (message.newWebhookEventId !== "") {
      obj.newWebhookEventId = message.newWebhookEventId;
    }
    if (message.originalWebhookEventId !== "") {
      obj.originalWebhookEventId = message.originalWebhookEventId;
    }
    if (message.forwardCount !== 0) {
      obj.forwardCount = Math.round(message.forwardCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayWebhookEventReply>): ReplayWebhookEventReply {
    return ReplayWebhookEventReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayWebhookEventReply>): ReplayWebhookEventReply {
    const message = createBaseReplayWebhookEventReply();
    message.newWebhookEventId = object.newWebhookEventId ?? "";
    message.originalWebhookEventId = object.originalWebhookEventId ?? "";
    message.forwardCount = object.forwardCount ?? 0;
    return message;
  },
};

function createBaseReplayTransactionStatusEventReq(): ReplayTransactionStatusEventReq {
  return { transactionId: undefined };
}

export const ReplayTransactionStatusEventReq: MessageFns<ReplayTransactionStatusEventReq> = {
  encode(message: ReplayTransactionStatusEventReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== undefined) {
      writer.uint32(10).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayTransactionStatusEventReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayTransactionStatusEventReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayTransactionStatusEventReq {
    return { transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : undefined };
  },

  toJSON(message: ReplayTransactionStatusEventReq): unknown {
    const obj: any = {};
    if (message.transactionId !== undefined) {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayTransactionStatusEventReq>): ReplayTransactionStatusEventReq {
    return ReplayTransactionStatusEventReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayTransactionStatusEventReq>): ReplayTransactionStatusEventReq {
    const message = createBaseReplayTransactionStatusEventReq();
    message.transactionId = object.transactionId ?? undefined;
    return message;
  },
};

function createBaseReplayTransactionStatusEventReply(): ReplayTransactionStatusEventReply {
  return { status: "" };
}

export const ReplayTransactionStatusEventReply: MessageFns<ReplayTransactionStatusEventReply> = {
  encode(message: ReplayTransactionStatusEventReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayTransactionStatusEventReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayTransactionStatusEventReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayTransactionStatusEventReply {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: ReplayTransactionStatusEventReply): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayTransactionStatusEventReply>): ReplayTransactionStatusEventReply {
    return ReplayTransactionStatusEventReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayTransactionStatusEventReply>): ReplayTransactionStatusEventReply {
    const message = createBaseReplayTransactionStatusEventReply();
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseUpdateCardCardMetaReq(): UpdateCardCardMetaReq {
  return { cardId: "", channelId: "" };
}

export const UpdateCardCardMetaReq: MessageFns<UpdateCardCardMetaReq> = {
  encode(message: UpdateCardCardMetaReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCardCardMetaReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCardCardMetaReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCardCardMetaReq {
    return {
      cardId: isSet(object.cardId) ? globalThis.String(object.cardId) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
    };
  },

  toJSON(message: UpdateCardCardMetaReq): unknown {
    const obj: any = {};
    if (message.cardId !== "") {
      obj.cardId = message.cardId;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCardCardMetaReq>): UpdateCardCardMetaReq {
    return UpdateCardCardMetaReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCardCardMetaReq>): UpdateCardCardMetaReq {
    const message = createBaseUpdateCardCardMetaReq();
    message.cardId = object.cardId ?? "";
    message.channelId = object.channelId ?? "";
    return message;
  },
};

function createBaseUpdateCardCardMetaReply(): UpdateCardCardMetaReply {
  return { cardId: "", card: undefined, stats: undefined };
}

export const UpdateCardCardMetaReply: MessageFns<UpdateCardCardMetaReply> = {
  encode(message: UpdateCardCardMetaReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    if (message.card !== undefined) {
      Card.encode(message.card, writer.uint32(18).fork()).join();
    }
    if (message.stats !== undefined) {
      CardStats.encode(message.stats, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCardCardMetaReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCardCardMetaReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.card = Card.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stats = CardStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCardCardMetaReply {
    return {
      cardId: isSet(object.cardId) ? globalThis.String(object.cardId) : "",
      card: isSet(object.card) ? Card.fromJSON(object.card) : undefined,
      stats: isSet(object.stats) ? CardStats.fromJSON(object.stats) : undefined,
    };
  },

  toJSON(message: UpdateCardCardMetaReply): unknown {
    const obj: any = {};
    if (message.cardId !== "") {
      obj.cardId = message.cardId;
    }
    if (message.card !== undefined) {
      obj.card = Card.toJSON(message.card);
    }
    if (message.stats !== undefined) {
      obj.stats = CardStats.toJSON(message.stats);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCardCardMetaReply>): UpdateCardCardMetaReply {
    return UpdateCardCardMetaReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCardCardMetaReply>): UpdateCardCardMetaReply {
    const message = createBaseUpdateCardCardMetaReply();
    message.cardId = object.cardId ?? "";
    message.card = (object.card !== undefined && object.card !== null) ? Card.fromPartial(object.card) : undefined;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? CardStats.fromPartial(object.stats)
      : undefined;
    return message;
  },
};

export type AdminDefinition = typeof AdminDefinition;
export const AdminDefinition = {
  name: "Admin",
  fullName: "admin.v1.Admin",
  methods: {
    getWebhookEvents: {
      name: "GetWebhookEvents",
      requestType: GetWebhookEventsReq,
      requestStream: false,
      responseType: GetWebhookEventsReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              23,
              18,
              21,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    getTransactionStatusLogs: {
      name: "GetTransactionStatusLogs",
      requestType: GetTransactionStatusLogsReq,
      requestStream: false,
      responseType: GetTransactionStatusLogsReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              32,
              18,
              30,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              47,
              115,
              116,
              97,
              116,
              117,
              115,
              47,
              108,
              111,
              103,
              115,
            ]),
          ],
        },
      },
    },
    replayWebhookEvent: {
      name: "ReplayWebhookEvent",
      requestType: ReplayWebhookEventReq,
      requestStream: false,
      responseType: ReplayWebhookEventReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              26,
              34,
              21,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
    replayTransactionStatusEvent: {
      name: "ReplayTransactionStatusEvent",
      requestType: ReplayTransactionStatusEventReq,
      requestStream: false,
      responseType: ReplayTransactionStatusEventReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              37,
              34,
              32,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              47,
              115,
              116,
              97,
              116,
              117,
              115,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
    updateCardCardMeta: {
      name: "UpdateCardCardMeta",
      requestType: UpdateCardCardMetaReq,
      requestStream: false,
      responseType: UpdateCardCardMetaReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              28,
              34,
              23,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              99,
              97,
              114,
              100,
              47,
              109,
              101,
              116,
              97,
              47,
              117,
              112,
              100,
              97,
              116,
              101,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
    migrateCardTemp: {
      name: "MigrateCardTemp",
      requestType: MigrateCardTempReq,
      requestStream: false,
      responseType: MigrateCardTempReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              29,
              26,
              24,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              99,
              97,
              114,
              100,
              47,
              116,
              101,
              109,
              112,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              101,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AdminServiceImplementation<CallContextExt = {}> {
  getWebhookEvents(
    request: GetWebhookEventsReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetWebhookEventsReply>>;
  getTransactionStatusLogs(
    request: GetTransactionStatusLogsReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetTransactionStatusLogsReply>>;
  replayWebhookEvent(
    request: ReplayWebhookEventReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReplayWebhookEventReply>>;
  replayTransactionStatusEvent(
    request: ReplayTransactionStatusEventReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReplayTransactionStatusEventReply>>;
  updateCardCardMeta(
    request: UpdateCardCardMetaReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UpdateCardCardMetaReply>>;
  migrateCardTemp(
    request: MigrateCardTempReq,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<MigrateCardTempReply>>;
}

export interface AdminClient<CallOptionsExt = {}> {
  getWebhookEvents(
    request: DeepPartial<GetWebhookEventsReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetWebhookEventsReply>;
  getTransactionStatusLogs(
    request: DeepPartial<GetTransactionStatusLogsReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetTransactionStatusLogsReply>;
  replayWebhookEvent(
    request: DeepPartial<ReplayWebhookEventReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReplayWebhookEventReply>;
  replayTransactionStatusEvent(
    request: DeepPartial<ReplayTransactionStatusEventReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReplayTransactionStatusEventReply>;
  updateCardCardMeta(
    request: DeepPartial<UpdateCardCardMetaReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UpdateCardCardMetaReply>;
  migrateCardTemp(
    request: DeepPartial<MigrateCardTempReq>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<MigrateCardTempReply>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
