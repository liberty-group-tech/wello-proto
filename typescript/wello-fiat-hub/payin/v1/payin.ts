// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: wello-fiat-hub/payin/v1/payin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Callback as Callback1, Filter, Fingerprint, Identity, OrderBy, Paging } from "../../shared/v1/misc";
import { BankAccount, PaymentMethod } from "../../shared/v1/payment_method";

export const protobufPackage = "payin.v1";

export interface PayRequest {
  channelId: string;
  amount: string;
  currency: string;
  referenceId?: string | undefined;
  description?: string | undefined;
  identity?: Identity | undefined;
  paymentMethod: PaymentMethod | undefined;
  fingerprint?: Fingerprint | undefined;
  callback?: Callback1 | undefined;
}

export interface Callback {
  successUrl?: string | undefined;
  failureUrl?: string | undefined;
  webhookUrl?: string | undefined;
}

export interface PayReply {
  id: string;
  amount: string;
  currency: string;
  status: string;
  statusCode: number;
  channelId: string;
  channelStatus: string;
  channelMessage: string;
  referenceId?: string | undefined;
  channelReferenceId?: string | undefined;
  identity?: Identity | undefined;
  paymentMethod?: PaymentMethod | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  redirect?: RedirectAuthorization | undefined;
  bankTransfer?:
    | BankTransferAuthorization
    | undefined;
  /** more methods */
  qrCode?: QrCodeAuthorization | undefined;
}

export interface RedirectAuthorization {
  uri: string;
  expiresAt?: Date | undefined;
}

export interface BankTransferAuthorization {
  bankAccount: BankAccount | undefined;
  note?: string | undefined;
  reference?: string | undefined;
}

export interface QrCodeAuthorization {
  uri: string;
  expiresAt?: Date | undefined;
}

export interface ChannelReferenceId {
  channelId: string;
  referenceId: string;
}

export interface RefundRequest {
  orderId: string;
  amount?: string | undefined;
  currency?: string | undefined;
  note?: string | undefined;
  referenceId?: string | undefined;
}

export interface RefundReply {
  id: string;
  status: string;
  statusCode: number;
  message: string;
  channelStatus: string;
  channelReferenceId: string;
  referenceId?: string | undefined;
}

export interface VoidRequest {
  orderId: string;
  note?: string | undefined;
}

export interface VoidReply {
  id: string;
  status: string;
  message: string;
  channelStatus: string;
}

export interface CaptureRequest {
  orderId: string;
}

export interface CaptureReply {
  id: string;
  status: string;
  message: string;
}

export interface Transaction {
  id: string;
  amount: string;
  fulfillAmount: string;
  currency: string;
  description?: string | undefined;
  status: string;
  statusCode: number;
  paymentMethodType: string;
  channelId: string;
  channelStatus?: string | undefined;
  channelMessage?: string | undefined;
  referenceId?: string | undefined;
  channelReferenceId?: string | undefined;
  identity?: Identity | undefined;
  paymentMethod?: PaymentMethod | undefined;
  fingerprint?: Fingerprint | undefined;
  callback?: Callback1 | undefined;
  redirect?:
    | RedirectAuthorization
    | undefined;
  /** more methods */
  bankTransfer?: BankTransferAuthorization | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  rawResponse?: string | undefined;
  annotation: { [key: string]: string };
  clientId: string;
  updatedBy?: string | undefined;
  updateReason?: string | undefined;
}

export interface Transaction_AnnotationEntry {
  key: string;
  value: string;
}

export interface GetTransactionRequest {
  id?: string | undefined;
  referenceId?: string | undefined;
  channelReferenceId?: GetTransactionRequest_ChannelReferenceId | undefined;
}

export interface GetTransactionRequest_ChannelReferenceId {
  channelId: string;
  referenceId: string;
}

export interface GetTransactionsReply {
  total: number;
  skip: number;
  limit: number;
  transactions: Transaction[];
}

export interface GetTransactionsRequest {
  paging: Paging | undefined;
  filters: Filter[];
  orderBy: OrderBy[];
}

function createBasePayRequest(): PayRequest {
  return {
    channelId: "",
    amount: "",
    currency: "",
    referenceId: undefined,
    description: undefined,
    identity: undefined,
    paymentMethod: undefined,
    fingerprint: undefined,
    callback: undefined,
  };
}

export const PayRequest: MessageFns<PayRequest> = {
  encode(message: PayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.referenceId !== undefined) {
      writer.uint32(34).string(message.referenceId);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.identity !== undefined) {
      Identity.encode(message.identity, writer.uint32(50).fork()).join();
    }
    if (message.paymentMethod !== undefined) {
      PaymentMethod.encode(message.paymentMethod, writer.uint32(58).fork()).join();
    }
    if (message.fingerprint !== undefined) {
      Fingerprint.encode(message.fingerprint, writer.uint32(66).fork()).join();
    }
    if (message.callback !== undefined) {
      Callback1.encode(message.callback, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.identity = Identity.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentMethod = PaymentMethod.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fingerprint = Fingerprint.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.callback = Callback1.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayRequest {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      identity: isSet(object.identity) ? Identity.fromJSON(object.identity) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? PaymentMethod.fromJSON(object.paymentMethod) : undefined,
      fingerprint: isSet(object.fingerprint) ? Fingerprint.fromJSON(object.fingerprint) : undefined,
      callback: isSet(object.callback) ? Callback1.fromJSON(object.callback) : undefined,
    };
  },

  toJSON(message: PayRequest): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.identity !== undefined) {
      obj.identity = Identity.toJSON(message.identity);
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = PaymentMethod.toJSON(message.paymentMethod);
    }
    if (message.fingerprint !== undefined) {
      obj.fingerprint = Fingerprint.toJSON(message.fingerprint);
    }
    if (message.callback !== undefined) {
      obj.callback = Callback1.toJSON(message.callback);
    }
    return obj;
  },

  create(base?: DeepPartial<PayRequest>): PayRequest {
    return PayRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PayRequest>): PayRequest {
    const message = createBasePayRequest();
    message.channelId = object.channelId ?? "";
    message.amount = object.amount ?? "";
    message.currency = object.currency ?? "";
    message.referenceId = object.referenceId ?? undefined;
    message.description = object.description ?? undefined;
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? Identity.fromPartial(object.identity)
      : undefined;
    message.paymentMethod = (object.paymentMethod !== undefined && object.paymentMethod !== null)
      ? PaymentMethod.fromPartial(object.paymentMethod)
      : undefined;
    message.fingerprint = (object.fingerprint !== undefined && object.fingerprint !== null)
      ? Fingerprint.fromPartial(object.fingerprint)
      : undefined;
    message.callback = (object.callback !== undefined && object.callback !== null)
      ? Callback1.fromPartial(object.callback)
      : undefined;
    return message;
  },
};

function createBaseCallback(): Callback {
  return { successUrl: undefined, failureUrl: undefined, webhookUrl: undefined };
}

export const Callback: MessageFns<Callback> = {
  encode(message: Callback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.successUrl !== undefined) {
      writer.uint32(10).string(message.successUrl);
    }
    if (message.failureUrl !== undefined) {
      writer.uint32(18).string(message.failureUrl);
    }
    if (message.webhookUrl !== undefined) {
      writer.uint32(26).string(message.webhookUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Callback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failureUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.webhookUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Callback {
    return {
      successUrl: isSet(object.successUrl) ? globalThis.String(object.successUrl) : undefined,
      failureUrl: isSet(object.failureUrl) ? globalThis.String(object.failureUrl) : undefined,
      webhookUrl: isSet(object.webhookUrl) ? globalThis.String(object.webhookUrl) : undefined,
    };
  },

  toJSON(message: Callback): unknown {
    const obj: any = {};
    if (message.successUrl !== undefined) {
      obj.successUrl = message.successUrl;
    }
    if (message.failureUrl !== undefined) {
      obj.failureUrl = message.failureUrl;
    }
    if (message.webhookUrl !== undefined) {
      obj.webhookUrl = message.webhookUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<Callback>): Callback {
    return Callback.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Callback>): Callback {
    const message = createBaseCallback();
    message.successUrl = object.successUrl ?? undefined;
    message.failureUrl = object.failureUrl ?? undefined;
    message.webhookUrl = object.webhookUrl ?? undefined;
    return message;
  },
};

function createBasePayReply(): PayReply {
  return {
    id: "",
    amount: "",
    currency: "",
    status: "",
    statusCode: 0,
    channelId: "",
    channelStatus: "",
    channelMessage: "",
    referenceId: undefined,
    channelReferenceId: undefined,
    identity: undefined,
    paymentMethod: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    redirect: undefined,
    bankTransfer: undefined,
    qrCode: undefined,
  };
}

export const PayReply: MessageFns<PayReply> = {
  encode(message: PayReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.statusCode !== 0) {
      writer.uint32(40).int32(message.statusCode);
    }
    if (message.channelId !== "") {
      writer.uint32(50).string(message.channelId);
    }
    if (message.channelStatus !== "") {
      writer.uint32(58).string(message.channelStatus);
    }
    if (message.channelMessage !== "") {
      writer.uint32(66).string(message.channelMessage);
    }
    if (message.referenceId !== undefined) {
      writer.uint32(74).string(message.referenceId);
    }
    if (message.channelReferenceId !== undefined) {
      writer.uint32(82).string(message.channelReferenceId);
    }
    if (message.identity !== undefined) {
      Identity.encode(message.identity, writer.uint32(90).fork()).join();
    }
    if (message.paymentMethod !== undefined) {
      PaymentMethod.encode(message.paymentMethod, writer.uint32(98).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(106).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(114).fork()).join();
    }
    if (message.redirect !== undefined) {
      RedirectAuthorization.encode(message.redirect, writer.uint32(122).fork()).join();
    }
    if (message.bankTransfer !== undefined) {
      BankTransferAuthorization.encode(message.bankTransfer, writer.uint32(130).fork()).join();
    }
    if (message.qrCode !== undefined) {
      QrCodeAuthorization.encode(message.qrCode, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.channelStatus = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.channelMessage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.channelReferenceId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.identity = Identity.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.paymentMethod = PaymentMethod.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.redirect = RedirectAuthorization.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.bankTransfer = BankTransferAuthorization.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.qrCode = QrCodeAuthorization.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayReply {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      channelStatus: isSet(object.channelStatus) ? globalThis.String(object.channelStatus) : "",
      channelMessage: isSet(object.channelMessage) ? globalThis.String(object.channelMessage) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
      channelReferenceId: isSet(object.channelReferenceId) ? globalThis.String(object.channelReferenceId) : undefined,
      identity: isSet(object.identity) ? Identity.fromJSON(object.identity) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? PaymentMethod.fromJSON(object.paymentMethod) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      redirect: isSet(object.redirect) ? RedirectAuthorization.fromJSON(object.redirect) : undefined,
      bankTransfer: isSet(object.bankTransfer) ? BankTransferAuthorization.fromJSON(object.bankTransfer) : undefined,
      qrCode: isSet(object.qrCode) ? QrCodeAuthorization.fromJSON(object.qrCode) : undefined,
    };
  },

  toJSON(message: PayReply): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.channelStatus !== "") {
      obj.channelStatus = message.channelStatus;
    }
    if (message.channelMessage !== "") {
      obj.channelMessage = message.channelMessage;
    }
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.channelReferenceId !== undefined) {
      obj.channelReferenceId = message.channelReferenceId;
    }
    if (message.identity !== undefined) {
      obj.identity = Identity.toJSON(message.identity);
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = PaymentMethod.toJSON(message.paymentMethod);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.redirect !== undefined) {
      obj.redirect = RedirectAuthorization.toJSON(message.redirect);
    }
    if (message.bankTransfer !== undefined) {
      obj.bankTransfer = BankTransferAuthorization.toJSON(message.bankTransfer);
    }
    if (message.qrCode !== undefined) {
      obj.qrCode = QrCodeAuthorization.toJSON(message.qrCode);
    }
    return obj;
  },

  create(base?: DeepPartial<PayReply>): PayReply {
    return PayReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PayReply>): PayReply {
    const message = createBasePayReply();
    message.id = object.id ?? "";
    message.amount = object.amount ?? "";
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.statusCode = object.statusCode ?? 0;
    message.channelId = object.channelId ?? "";
    message.channelStatus = object.channelStatus ?? "";
    message.channelMessage = object.channelMessage ?? "";
    message.referenceId = object.referenceId ?? undefined;
    message.channelReferenceId = object.channelReferenceId ?? undefined;
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? Identity.fromPartial(object.identity)
      : undefined;
    message.paymentMethod = (object.paymentMethod !== undefined && object.paymentMethod !== null)
      ? PaymentMethod.fromPartial(object.paymentMethod)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.redirect = (object.redirect !== undefined && object.redirect !== null)
      ? RedirectAuthorization.fromPartial(object.redirect)
      : undefined;
    message.bankTransfer = (object.bankTransfer !== undefined && object.bankTransfer !== null)
      ? BankTransferAuthorization.fromPartial(object.bankTransfer)
      : undefined;
    message.qrCode = (object.qrCode !== undefined && object.qrCode !== null)
      ? QrCodeAuthorization.fromPartial(object.qrCode)
      : undefined;
    return message;
  },
};

function createBaseRedirectAuthorization(): RedirectAuthorization {
  return { uri: "", expiresAt: undefined };
}

export const RedirectAuthorization: MessageFns<RedirectAuthorization> = {
  encode(message: RedirectAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedirectAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedirectAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedirectAuthorization {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: RedirectAuthorization): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RedirectAuthorization>): RedirectAuthorization {
    return RedirectAuthorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RedirectAuthorization>): RedirectAuthorization {
    const message = createBaseRedirectAuthorization();
    message.uri = object.uri ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseBankTransferAuthorization(): BankTransferAuthorization {
  return { bankAccount: undefined, note: undefined, reference: undefined };
}

export const BankTransferAuthorization: MessageFns<BankTransferAuthorization> = {
  encode(message: BankTransferAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bankAccount !== undefined) {
      BankAccount.encode(message.bankAccount, writer.uint32(10).fork()).join();
    }
    if (message.note !== undefined) {
      writer.uint32(18).string(message.note);
    }
    if (message.reference !== undefined) {
      writer.uint32(26).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankTransferAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankTransferAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bankAccount = BankAccount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankTransferAuthorization {
    return {
      bankAccount: isSet(object.bankAccount) ? BankAccount.fromJSON(object.bankAccount) : undefined,
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: BankTransferAuthorization): unknown {
    const obj: any = {};
    if (message.bankAccount !== undefined) {
      obj.bankAccount = BankAccount.toJSON(message.bankAccount);
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<BankTransferAuthorization>): BankTransferAuthorization {
    return BankTransferAuthorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BankTransferAuthorization>): BankTransferAuthorization {
    const message = createBaseBankTransferAuthorization();
    message.bankAccount = (object.bankAccount !== undefined && object.bankAccount !== null)
      ? BankAccount.fromPartial(object.bankAccount)
      : undefined;
    message.note = object.note ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseQrCodeAuthorization(): QrCodeAuthorization {
  return { uri: "", expiresAt: undefined };
}

export const QrCodeAuthorization: MessageFns<QrCodeAuthorization> = {
  encode(message: QrCodeAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QrCodeAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQrCodeAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QrCodeAuthorization {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: QrCodeAuthorization): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<QrCodeAuthorization>): QrCodeAuthorization {
    return QrCodeAuthorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QrCodeAuthorization>): QrCodeAuthorization {
    const message = createBaseQrCodeAuthorization();
    message.uri = object.uri ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseChannelReferenceId(): ChannelReferenceId {
  return { channelId: "", referenceId: "" };
}

export const ChannelReferenceId: MessageFns<ChannelReferenceId> = {
  encode(message: ChannelReferenceId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.referenceId !== "") {
      writer.uint32(18).string(message.referenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelReferenceId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelReferenceId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelReferenceId {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "",
    };
  },

  toJSON(message: ChannelReferenceId): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    return obj;
  },

  create(base?: DeepPartial<ChannelReferenceId>): ChannelReferenceId {
    return ChannelReferenceId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChannelReferenceId>): ChannelReferenceId {
    const message = createBaseChannelReferenceId();
    message.channelId = object.channelId ?? "";
    message.referenceId = object.referenceId ?? "";
    return message;
  },
};

function createBaseRefundRequest(): RefundRequest {
  return { orderId: "", amount: undefined, currency: undefined, note: undefined, referenceId: undefined };
}

export const RefundRequest: MessageFns<RefundRequest> = {
  encode(message: RefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.amount !== undefined) {
      writer.uint32(18).string(message.amount);
    }
    if (message.currency !== undefined) {
      writer.uint32(26).string(message.currency);
    }
    if (message.note !== undefined) {
      writer.uint32(34).string(message.note);
    }
    if (message.referenceId !== undefined) {
      writer.uint32(42).string(message.referenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : undefined,
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
    };
  },

  toJSON(message: RefundRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.currency !== undefined) {
      obj.currency = message.currency;
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    return obj;
  },

  create(base?: DeepPartial<RefundRequest>): RefundRequest {
    return RefundRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefundRequest>): RefundRequest {
    const message = createBaseRefundRequest();
    message.orderId = object.orderId ?? "";
    message.amount = object.amount ?? undefined;
    message.currency = object.currency ?? undefined;
    message.note = object.note ?? undefined;
    message.referenceId = object.referenceId ?? undefined;
    return message;
  },
};

function createBaseRefundReply(): RefundReply {
  return {
    id: "",
    status: "",
    statusCode: 0,
    message: "",
    channelStatus: "",
    channelReferenceId: "",
    referenceId: undefined,
  };
}

export const RefundReply: MessageFns<RefundReply> = {
  encode(message: RefundReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.statusCode !== 0) {
      writer.uint32(24).int32(message.statusCode);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.channelStatus !== "") {
      writer.uint32(42).string(message.channelStatus);
    }
    if (message.channelReferenceId !== "") {
      writer.uint32(50).string(message.channelReferenceId);
    }
    if (message.referenceId !== undefined) {
      writer.uint32(58).string(message.referenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.channelStatus = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.channelReferenceId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundReply {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      channelStatus: isSet(object.channelStatus) ? globalThis.String(object.channelStatus) : "",
      channelReferenceId: isSet(object.channelReferenceId) ? globalThis.String(object.channelReferenceId) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
    };
  },

  toJSON(message: RefundReply): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.channelStatus !== "") {
      obj.channelStatus = message.channelStatus;
    }
    if (message.channelReferenceId !== "") {
      obj.channelReferenceId = message.channelReferenceId;
    }
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    return obj;
  },

  create(base?: DeepPartial<RefundReply>): RefundReply {
    return RefundReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefundReply>): RefundReply {
    const message = createBaseRefundReply();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.statusCode = object.statusCode ?? 0;
    message.message = object.message ?? "";
    message.channelStatus = object.channelStatus ?? "";
    message.channelReferenceId = object.channelReferenceId ?? "";
    message.referenceId = object.referenceId ?? undefined;
    return message;
  },
};

function createBaseVoidRequest(): VoidRequest {
  return { orderId: "", note: undefined };
}

export const VoidRequest: MessageFns<VoidRequest> = {
  encode(message: VoidRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.note !== undefined) {
      writer.uint32(18).string(message.note);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoidRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.note = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoidRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
    };
  },

  toJSON(message: VoidRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    return obj;
  },

  create(base?: DeepPartial<VoidRequest>): VoidRequest {
    return VoidRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VoidRequest>): VoidRequest {
    const message = createBaseVoidRequest();
    message.orderId = object.orderId ?? "";
    message.note = object.note ?? undefined;
    return message;
  },
};

function createBaseVoidReply(): VoidReply {
  return { id: "", status: "", message: "", channelStatus: "" };
}

export const VoidReply: MessageFns<VoidReply> = {
  encode(message: VoidReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.channelStatus !== "") {
      writer.uint32(34).string(message.channelStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoidReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoidReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channelStatus = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoidReply {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      channelStatus: isSet(object.channelStatus) ? globalThis.String(object.channelStatus) : "",
    };
  },

  toJSON(message: VoidReply): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.channelStatus !== "") {
      obj.channelStatus = message.channelStatus;
    }
    return obj;
  },

  create(base?: DeepPartial<VoidReply>): VoidReply {
    return VoidReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VoidReply>): VoidReply {
    const message = createBaseVoidReply();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.message = object.message ?? "";
    message.channelStatus = object.channelStatus ?? "";
    return message;
  },
};

function createBaseCaptureRequest(): CaptureRequest {
  return { orderId: "" };
}

export const CaptureRequest: MessageFns<CaptureRequest> = {
  encode(message: CaptureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaptureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: CaptureRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create(base?: DeepPartial<CaptureRequest>): CaptureRequest {
    return CaptureRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaptureRequest>): CaptureRequest {
    const message = createBaseCaptureRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseCaptureReply(): CaptureReply {
  return { id: "", status: "", message: "" };
}

export const CaptureReply: MessageFns<CaptureReply> = {
  encode(message: CaptureReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaptureReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureReply {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CaptureReply): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CaptureReply>): CaptureReply {
    return CaptureReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaptureReply>): CaptureReply {
    const message = createBaseCaptureReply();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    id: "",
    amount: "",
    fulfillAmount: "",
    currency: "",
    description: undefined,
    status: "",
    statusCode: 0,
    paymentMethodType: "",
    channelId: "",
    channelStatus: undefined,
    channelMessage: undefined,
    referenceId: undefined,
    channelReferenceId: undefined,
    identity: undefined,
    paymentMethod: undefined,
    fingerprint: undefined,
    callback: undefined,
    redirect: undefined,
    bankTransfer: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    rawResponse: undefined,
    annotation: {},
    clientId: "",
    updatedBy: undefined,
    updateReason: undefined,
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.fulfillAmount !== "") {
      writer.uint32(26).string(message.fulfillAmount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.statusCode !== 0) {
      writer.uint32(56).int32(message.statusCode);
    }
    if (message.paymentMethodType !== "") {
      writer.uint32(66).string(message.paymentMethodType);
    }
    if (message.channelId !== "") {
      writer.uint32(74).string(message.channelId);
    }
    if (message.channelStatus !== undefined) {
      writer.uint32(82).string(message.channelStatus);
    }
    if (message.channelMessage !== undefined) {
      writer.uint32(90).string(message.channelMessage);
    }
    if (message.referenceId !== undefined) {
      writer.uint32(98).string(message.referenceId);
    }
    if (message.channelReferenceId !== undefined) {
      writer.uint32(106).string(message.channelReferenceId);
    }
    if (message.identity !== undefined) {
      Identity.encode(message.identity, writer.uint32(114).fork()).join();
    }
    if (message.paymentMethod !== undefined) {
      PaymentMethod.encode(message.paymentMethod, writer.uint32(122).fork()).join();
    }
    if (message.fingerprint !== undefined) {
      Fingerprint.encode(message.fingerprint, writer.uint32(130).fork()).join();
    }
    if (message.callback !== undefined) {
      Callback1.encode(message.callback, writer.uint32(138).fork()).join();
    }
    if (message.redirect !== undefined) {
      RedirectAuthorization.encode(message.redirect, writer.uint32(146).fork()).join();
    }
    if (message.bankTransfer !== undefined) {
      BankTransferAuthorization.encode(message.bankTransfer, writer.uint32(154).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(162).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(170).fork()).join();
    }
    if (message.rawResponse !== undefined) {
      writer.uint32(178).string(message.rawResponse);
    }
    Object.entries(message.annotation).forEach(([key, value]) => {
      Transaction_AnnotationEntry.encode({ key: key as any, value }, writer.uint32(186).fork()).join();
    });
    if (message.clientId !== "") {
      writer.uint32(194).string(message.clientId);
    }
    if (message.updatedBy !== undefined) {
      writer.uint32(202).string(message.updatedBy);
    }
    if (message.updateReason !== undefined) {
      writer.uint32(210).string(message.updateReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fulfillAmount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.paymentMethodType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.channelStatus = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.channelMessage = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.channelReferenceId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.identity = Identity.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.paymentMethod = PaymentMethod.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.fingerprint = Fingerprint.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.callback = Callback1.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.redirect = RedirectAuthorization.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.bankTransfer = BankTransferAuthorization.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.rawResponse = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          const entry23 = Transaction_AnnotationEntry.decode(reader, reader.uint32());
          if (entry23.value !== undefined) {
            message.annotation[entry23.key] = entry23.value;
          }
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.updateReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      fulfillAmount: isSet(object.fulfillAmount) ? globalThis.String(object.fulfillAmount) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      paymentMethodType: isSet(object.paymentMethodType) ? globalThis.String(object.paymentMethodType) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      channelStatus: isSet(object.channelStatus) ? globalThis.String(object.channelStatus) : undefined,
      channelMessage: isSet(object.channelMessage) ? globalThis.String(object.channelMessage) : undefined,
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
      channelReferenceId: isSet(object.channelReferenceId) ? globalThis.String(object.channelReferenceId) : undefined,
      identity: isSet(object.identity) ? Identity.fromJSON(object.identity) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? PaymentMethod.fromJSON(object.paymentMethod) : undefined,
      fingerprint: isSet(object.fingerprint) ? Fingerprint.fromJSON(object.fingerprint) : undefined,
      callback: isSet(object.callback) ? Callback1.fromJSON(object.callback) : undefined,
      redirect: isSet(object.redirect) ? RedirectAuthorization.fromJSON(object.redirect) : undefined,
      bankTransfer: isSet(object.bankTransfer) ? BankTransferAuthorization.fromJSON(object.bankTransfer) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      rawResponse: isSet(object.rawResponse) ? globalThis.String(object.rawResponse) : undefined,
      annotation: isObject(object.annotation)
        ? Object.entries(object.annotation).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : undefined,
      updateReason: isSet(object.updateReason) ? globalThis.String(object.updateReason) : undefined,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.fulfillAmount !== "") {
      obj.fulfillAmount = message.fulfillAmount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.paymentMethodType !== "") {
      obj.paymentMethodType = message.paymentMethodType;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.channelStatus !== undefined) {
      obj.channelStatus = message.channelStatus;
    }
    if (message.channelMessage !== undefined) {
      obj.channelMessage = message.channelMessage;
    }
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.channelReferenceId !== undefined) {
      obj.channelReferenceId = message.channelReferenceId;
    }
    if (message.identity !== undefined) {
      obj.identity = Identity.toJSON(message.identity);
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = PaymentMethod.toJSON(message.paymentMethod);
    }
    if (message.fingerprint !== undefined) {
      obj.fingerprint = Fingerprint.toJSON(message.fingerprint);
    }
    if (message.callback !== undefined) {
      obj.callback = Callback1.toJSON(message.callback);
    }
    if (message.redirect !== undefined) {
      obj.redirect = RedirectAuthorization.toJSON(message.redirect);
    }
    if (message.bankTransfer !== undefined) {
      obj.bankTransfer = BankTransferAuthorization.toJSON(message.bankTransfer);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.rawResponse !== undefined) {
      obj.rawResponse = message.rawResponse;
    }
    if (message.annotation) {
      const entries = Object.entries(message.annotation);
      if (entries.length > 0) {
        obj.annotation = {};
        entries.forEach(([k, v]) => {
          obj.annotation[k] = v;
        });
      }
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.updatedBy !== undefined) {
      obj.updatedBy = message.updatedBy;
    }
    if (message.updateReason !== undefined) {
      obj.updateReason = message.updateReason;
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction();
    message.id = object.id ?? "";
    message.amount = object.amount ?? "";
    message.fulfillAmount = object.fulfillAmount ?? "";
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.status = object.status ?? "";
    message.statusCode = object.statusCode ?? 0;
    message.paymentMethodType = object.paymentMethodType ?? "";
    message.channelId = object.channelId ?? "";
    message.channelStatus = object.channelStatus ?? undefined;
    message.channelMessage = object.channelMessage ?? undefined;
    message.referenceId = object.referenceId ?? undefined;
    message.channelReferenceId = object.channelReferenceId ?? undefined;
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? Identity.fromPartial(object.identity)
      : undefined;
    message.paymentMethod = (object.paymentMethod !== undefined && object.paymentMethod !== null)
      ? PaymentMethod.fromPartial(object.paymentMethod)
      : undefined;
    message.fingerprint = (object.fingerprint !== undefined && object.fingerprint !== null)
      ? Fingerprint.fromPartial(object.fingerprint)
      : undefined;
    message.callback = (object.callback !== undefined && object.callback !== null)
      ? Callback1.fromPartial(object.callback)
      : undefined;
    message.redirect = (object.redirect !== undefined && object.redirect !== null)
      ? RedirectAuthorization.fromPartial(object.redirect)
      : undefined;
    message.bankTransfer = (object.bankTransfer !== undefined && object.bankTransfer !== null)
      ? BankTransferAuthorization.fromPartial(object.bankTransfer)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.rawResponse = object.rawResponse ?? undefined;
    message.annotation = Object.entries(object.annotation ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.clientId = object.clientId ?? "";
    message.updatedBy = object.updatedBy ?? undefined;
    message.updateReason = object.updateReason ?? undefined;
    return message;
  },
};

function createBaseTransaction_AnnotationEntry(): Transaction_AnnotationEntry {
  return { key: "", value: "" };
}

export const Transaction_AnnotationEntry: MessageFns<Transaction_AnnotationEntry> = {
  encode(message: Transaction_AnnotationEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction_AnnotationEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction_AnnotationEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction_AnnotationEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Transaction_AnnotationEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction_AnnotationEntry>): Transaction_AnnotationEntry {
    return Transaction_AnnotationEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction_AnnotationEntry>): Transaction_AnnotationEntry {
    const message = createBaseTransaction_AnnotationEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetTransactionRequest(): GetTransactionRequest {
  return { id: undefined, referenceId: undefined, channelReferenceId: undefined };
}

export const GetTransactionRequest: MessageFns<GetTransactionRequest> = {
  encode(message: GetTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.referenceId !== undefined) {
      writer.uint32(18).string(message.referenceId);
    }
    if (message.channelReferenceId !== undefined) {
      GetTransactionRequest_ChannelReferenceId.encode(message.channelReferenceId, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channelReferenceId = GetTransactionRequest_ChannelReferenceId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
      channelReferenceId: isSet(object.channelReferenceId)
        ? GetTransactionRequest_ChannelReferenceId.fromJSON(object.channelReferenceId)
        : undefined,
    };
  },

  toJSON(message: GetTransactionRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.channelReferenceId !== undefined) {
      obj.channelReferenceId = GetTransactionRequest_ChannelReferenceId.toJSON(message.channelReferenceId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionRequest>): GetTransactionRequest {
    return GetTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionRequest>): GetTransactionRequest {
    const message = createBaseGetTransactionRequest();
    message.id = object.id ?? undefined;
    message.referenceId = object.referenceId ?? undefined;
    message.channelReferenceId = (object.channelReferenceId !== undefined && object.channelReferenceId !== null)
      ? GetTransactionRequest_ChannelReferenceId.fromPartial(object.channelReferenceId)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionRequest_ChannelReferenceId(): GetTransactionRequest_ChannelReferenceId {
  return { channelId: "", referenceId: "" };
}

export const GetTransactionRequest_ChannelReferenceId: MessageFns<GetTransactionRequest_ChannelReferenceId> = {
  encode(message: GetTransactionRequest_ChannelReferenceId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.referenceId !== "") {
      writer.uint32(18).string(message.referenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionRequest_ChannelReferenceId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionRequest_ChannelReferenceId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionRequest_ChannelReferenceId {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "",
    };
  },

  toJSON(message: GetTransactionRequest_ChannelReferenceId): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionRequest_ChannelReferenceId>): GetTransactionRequest_ChannelReferenceId {
    return GetTransactionRequest_ChannelReferenceId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionRequest_ChannelReferenceId>): GetTransactionRequest_ChannelReferenceId {
    const message = createBaseGetTransactionRequest_ChannelReferenceId();
    message.channelId = object.channelId ?? "";
    message.referenceId = object.referenceId ?? "";
    return message;
  },
};

function createBaseGetTransactionsReply(): GetTransactionsReply {
  return { total: 0, skip: 0, limit: 0, transactions: [] };
}

export const GetTransactionsReply: MessageFns<GetTransactionsReply> = {
  encode(message: GetTransactionsReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.skip !== 0) {
      writer.uint32(16).int32(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionsReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.skip = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionsReply {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      skip: isSet(object.skip) ? globalThis.Number(object.skip) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTransactionsReply): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.skip !== 0) {
      obj.skip = Math.round(message.skip);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionsReply>): GetTransactionsReply {
    return GetTransactionsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionsReply>): GetTransactionsReply {
    const message = createBaseGetTransactionsReply();
    message.total = object.total ?? 0;
    message.skip = object.skip ?? 0;
    message.limit = object.limit ?? 0;
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTransactionsRequest(): GetTransactionsRequest {
  return { paging: undefined, filters: [], orderBy: [] };
}

export const GetTransactionsRequest: MessageFns<GetTransactionsRequest> = {
  encode(message: GetTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(10).fork()).join();
    }
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.orderBy) {
      OrderBy.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paging = Paging.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderBy.push(OrderBy.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionsRequest {
    return {
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
      orderBy: globalThis.Array.isArray(object?.orderBy) ? object.orderBy.map((e: any) => OrderBy.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetTransactionsRequest): unknown {
    const obj: any = {};
    if (message.paging !== undefined) {
      obj.paging = Paging.toJSON(message.paging);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => OrderBy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionsRequest>): GetTransactionsRequest {
    return GetTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionsRequest>): GetTransactionsRequest {
    const message = createBaseGetTransactionsRequest();
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    message.orderBy = object.orderBy?.map((e) => OrderBy.fromPartial(e)) || [];
    return message;
  },
};

export type PayinDefinition = typeof PayinDefinition;
export const PayinDefinition = {
  name: "Payin",
  fullName: "payin.v1.Payin",
  methods: {
    pay: {
      name: "Pay",
      requestType: PayRequest,
      requestStream: false,
      responseType: PayReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              24,
              34,
              19,
              47,
              112,
              97,
              121,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
    refund: {
      name: "Refund",
      requestType: RefundRequest,
      requestStream: false,
      responseType: RefundReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              42,
              34,
              37,
              47,
              112,
              97,
              121,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              111,
              114,
              100,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              114,
              101,
              102,
              117,
              110,
              100,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
    void: {
      name: "Void",
      requestType: VoidRequest,
      requestStream: false,
      responseType: VoidReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              40,
              34,
              35,
              47,
              112,
              97,
              121,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              111,
              114,
              100,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              118,
              111,
              105,
              100,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
    capture: {
      name: "Capture",
      requestType: CaptureRequest,
      requestStream: false,
      responseType: CaptureReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              43,
              34,
              38,
              47,
              112,
              97,
              121,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              111,
              114,
              100,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              99,
              97,
              112,
              116,
              117,
              114,
              101,
              58,
              1,
              42,
            ]),
          ],
        },
      },
    },
    getTransaction: {
      name: "GetTransaction",
      requestType: GetTransactionRequest,
      requestStream: false,
      responseType: Transaction,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              26,
              18,
              24,
              47,
              112,
              97,
              121,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    getTransactions: {
      name: "GetTransactions",
      requestType: GetTransactionsRequest,
      requestStream: false,
      responseType: GetTransactionsReply,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              21,
              18,
              19,
              47,
              112,
              97,
              121,
              105,
              110,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface PayinServiceImplementation<CallContextExt = {}> {
  pay(request: PayRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PayReply>>;
  refund(request: RefundRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RefundReply>>;
  void(request: VoidRequest, context: CallContext & CallContextExt): Promise<DeepPartial<VoidReply>>;
  capture(request: CaptureRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CaptureReply>>;
  getTransaction(
    request: GetTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Transaction>>;
  getTransactions(
    request: GetTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetTransactionsReply>>;
}

export interface PayinClient<CallOptionsExt = {}> {
  pay(request: DeepPartial<PayRequest>, options?: CallOptions & CallOptionsExt): Promise<PayReply>;
  refund(request: DeepPartial<RefundRequest>, options?: CallOptions & CallOptionsExt): Promise<RefundReply>;
  void(request: DeepPartial<VoidRequest>, options?: CallOptions & CallOptionsExt): Promise<VoidReply>;
  capture(request: DeepPartial<CaptureRequest>, options?: CallOptions & CallOptionsExt): Promise<CaptureReply>;
  getTransaction(
    request: DeepPartial<GetTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Transaction>;
  getTransactions(
    request: DeepPartial<GetTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetTransactionsReply>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
