// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: wello-fiat-hub/shared/v1/payment_method.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Address } from "./misc";

export const protobufPackage = "shared.v1";

export interface PaymentMethod {
  id?: string | undefined;
  store?: boolean | undefined;
  type?: string | undefined;
  status?: string | undefined;
  userId?: string | undefined;
  card?: Card | undefined;
  mobileMoney?: MobileMoney | undefined;
  bankAccount?: BankAccount | undefined;
  bankTransfer?: BankTransfer | undefined;
  applePay?: ApplePay | undefined;
  openBanking?:
    | OpenBanking
    | undefined;
  /** also used for apple pay */
  cardAuthorization?: PaymentMethod_CardAuthorization | undefined;
}

export interface PaymentMethod_CardAuthorization {
  cvv?: string | undefined;
  autoCapture?: boolean | undefined;
  threeDsRequired?: boolean | undefined;
  threeDsAllowUpgrade?: boolean | undefined;
}

export interface Card {
  cardNumber: string;
  holderName: string;
  expiryMonth: number;
  expiryYear: number;
  billingAddress?: Address | undefined;
  bin?: string | undefined;
  last4?: string | undefined;
  scheme?: string | undefined;
  type?: string | undefined;
  issuer?: string | undefined;
  issueCountry?: string | undefined;
  productId?: string | undefined;
  productType?: string | undefined;
}

export interface CardStats {
  cardId: string;
  channelId: string;
  supportsPayin?: boolean | undefined;
  supportsPayout?: boolean | undefined;
  supportsFastFunds?: boolean | undefined;
  supportsCrossBoarderPayout?: boolean | undefined;
  supportsCrossBoarderFastFunds?: boolean | undefined;
  payinAttempts: number;
  payinSuccesses: number;
  payoutAttempts: number;
  payoutSuccesses: number;
  lastSuccessAt: Date | undefined;
  lastFailedAt: Date | undefined;
}

export interface PaymentData {
  version: string;
  data: string;
  signature: string;
  header: PaymentData_Header | undefined;
  decryptedData?: PaymentData_DecryptedData | undefined;
}

export interface PaymentData_Header {
  ephemeralPublicKey: string;
  publicKeyHash: string;
  transactionId: string;
}

export interface PaymentData_DecryptedData {
  token: string;
  tokenFormat: string;
  holderName: string;
  bin: string;
  lastFour: string;
  expiryYear: number;
  expiryMonth: number;
  type: string;
  category: string;
  scheme: string;
  issuer: string;
  issueCountry: string;
  productId: string;
  productType: string;
  phone: string;
}

export interface ApplePay {
  paymentData: PaymentData | undefined;
  billingAddress?: Address | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
}

export interface MobileMoney {
  subType: string;
  network?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
  fullname?: string | undefined;
  orderId?: string | undefined;
  txRef?: string | undefined;
  authorizationCode?: string | undefined;
  country?: string | undefined;
}

export interface BankAccount {
  accountNumber?: string | undefined;
  accountExpiration?: string | undefined;
  bankCode?: string | undefined;
  bankCountry?: string | undefined;
  bankName?: string | undefined;
  routingNumber?: string | undefined;
  sortCode?: string | undefined;
  swiftCode?: string | undefined;
  accountName?: string | undefined;
}

export interface BankTransfer {
  accountNumber?: string | undefined;
  fullname?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
}

export interface OpenBanking {
  provider?: string | undefined;
  bankId?: string | undefined;
  country?: string | undefined;
  accountNumber?: string | undefined;
  fullname?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
}

function createBasePaymentMethod(): PaymentMethod {
  return {
    id: undefined,
    store: undefined,
    type: undefined,
    status: undefined,
    userId: undefined,
    card: undefined,
    mobileMoney: undefined,
    bankAccount: undefined,
    bankTransfer: undefined,
    applePay: undefined,
    openBanking: undefined,
    cardAuthorization: undefined,
  };
}

export const PaymentMethod: MessageFns<PaymentMethod> = {
  encode(message: PaymentMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.store !== undefined) {
      writer.uint32(16).bool(message.store);
    }
    if (message.type !== undefined) {
      writer.uint32(26).string(message.type);
    }
    if (message.status !== undefined) {
      writer.uint32(34).string(message.status);
    }
    if (message.userId !== undefined) {
      writer.uint32(42).string(message.userId);
    }
    if (message.card !== undefined) {
      Card.encode(message.card, writer.uint32(50).fork()).join();
    }
    if (message.mobileMoney !== undefined) {
      MobileMoney.encode(message.mobileMoney, writer.uint32(58).fork()).join();
    }
    if (message.bankAccount !== undefined) {
      BankAccount.encode(message.bankAccount, writer.uint32(66).fork()).join();
    }
    if (message.bankTransfer !== undefined) {
      BankTransfer.encode(message.bankTransfer, writer.uint32(74).fork()).join();
    }
    if (message.applePay !== undefined) {
      ApplePay.encode(message.applePay, writer.uint32(82).fork()).join();
    }
    if (message.openBanking !== undefined) {
      OpenBanking.encode(message.openBanking, writer.uint32(90).fork()).join();
    }
    if (message.cardAuthorization !== undefined) {
      PaymentMethod_CardAuthorization.encode(message.cardAuthorization, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.store = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.card = Card.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mobileMoney = MobileMoney.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bankAccount = BankAccount.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bankTransfer = BankTransfer.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.applePay = ApplePay.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.openBanking = OpenBanking.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.cardAuthorization = PaymentMethod_CardAuthorization.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentMethod {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      store: isSet(object.store) ? globalThis.Boolean(object.store) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      card: isSet(object.card) ? Card.fromJSON(object.card) : undefined,
      mobileMoney: isSet(object.mobileMoney) ? MobileMoney.fromJSON(object.mobileMoney) : undefined,
      bankAccount: isSet(object.bankAccount) ? BankAccount.fromJSON(object.bankAccount) : undefined,
      bankTransfer: isSet(object.bankTransfer) ? BankTransfer.fromJSON(object.bankTransfer) : undefined,
      applePay: isSet(object.applePay) ? ApplePay.fromJSON(object.applePay) : undefined,
      openBanking: isSet(object.openBanking) ? OpenBanking.fromJSON(object.openBanking) : undefined,
      cardAuthorization: isSet(object.cardAuthorization)
        ? PaymentMethod_CardAuthorization.fromJSON(object.cardAuthorization)
        : undefined,
    };
  },

  toJSON(message: PaymentMethod): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.store !== undefined) {
      obj.store = message.store;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.card !== undefined) {
      obj.card = Card.toJSON(message.card);
    }
    if (message.mobileMoney !== undefined) {
      obj.mobileMoney = MobileMoney.toJSON(message.mobileMoney);
    }
    if (message.bankAccount !== undefined) {
      obj.bankAccount = BankAccount.toJSON(message.bankAccount);
    }
    if (message.bankTransfer !== undefined) {
      obj.bankTransfer = BankTransfer.toJSON(message.bankTransfer);
    }
    if (message.applePay !== undefined) {
      obj.applePay = ApplePay.toJSON(message.applePay);
    }
    if (message.openBanking !== undefined) {
      obj.openBanking = OpenBanking.toJSON(message.openBanking);
    }
    if (message.cardAuthorization !== undefined) {
      obj.cardAuthorization = PaymentMethod_CardAuthorization.toJSON(message.cardAuthorization);
    }
    return obj;
  },

  create(base?: DeepPartial<PaymentMethod>): PaymentMethod {
    return PaymentMethod.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaymentMethod>): PaymentMethod {
    const message = createBasePaymentMethod();
    message.id = object.id ?? undefined;
    message.store = object.store ?? undefined;
    message.type = object.type ?? undefined;
    message.status = object.status ?? undefined;
    message.userId = object.userId ?? undefined;
    message.card = (object.card !== undefined && object.card !== null) ? Card.fromPartial(object.card) : undefined;
    message.mobileMoney = (object.mobileMoney !== undefined && object.mobileMoney !== null)
      ? MobileMoney.fromPartial(object.mobileMoney)
      : undefined;
    message.bankAccount = (object.bankAccount !== undefined && object.bankAccount !== null)
      ? BankAccount.fromPartial(object.bankAccount)
      : undefined;
    message.bankTransfer = (object.bankTransfer !== undefined && object.bankTransfer !== null)
      ? BankTransfer.fromPartial(object.bankTransfer)
      : undefined;
    message.applePay = (object.applePay !== undefined && object.applePay !== null)
      ? ApplePay.fromPartial(object.applePay)
      : undefined;
    message.openBanking = (object.openBanking !== undefined && object.openBanking !== null)
      ? OpenBanking.fromPartial(object.openBanking)
      : undefined;
    message.cardAuthorization = (object.cardAuthorization !== undefined && object.cardAuthorization !== null)
      ? PaymentMethod_CardAuthorization.fromPartial(object.cardAuthorization)
      : undefined;
    return message;
  },
};

function createBasePaymentMethod_CardAuthorization(): PaymentMethod_CardAuthorization {
  return { cvv: undefined, autoCapture: undefined, threeDsRequired: undefined, threeDsAllowUpgrade: undefined };
}

export const PaymentMethod_CardAuthorization: MessageFns<PaymentMethod_CardAuthorization> = {
  encode(message: PaymentMethod_CardAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cvv !== undefined) {
      writer.uint32(10).string(message.cvv);
    }
    if (message.autoCapture !== undefined) {
      writer.uint32(16).bool(message.autoCapture);
    }
    if (message.threeDsRequired !== undefined) {
      writer.uint32(24).bool(message.threeDsRequired);
    }
    if (message.threeDsAllowUpgrade !== undefined) {
      writer.uint32(32).bool(message.threeDsAllowUpgrade);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentMethod_CardAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentMethod_CardAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cvv = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.autoCapture = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.threeDsRequired = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.threeDsAllowUpgrade = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentMethod_CardAuthorization {
    return {
      cvv: isSet(object.cvv) ? globalThis.String(object.cvv) : undefined,
      autoCapture: isSet(object.autoCapture) ? globalThis.Boolean(object.autoCapture) : undefined,
      threeDsRequired: isSet(object.threeDsRequired) ? globalThis.Boolean(object.threeDsRequired) : undefined,
      threeDsAllowUpgrade: isSet(object.threeDsAllowUpgrade)
        ? globalThis.Boolean(object.threeDsAllowUpgrade)
        : undefined,
    };
  },

  toJSON(message: PaymentMethod_CardAuthorization): unknown {
    const obj: any = {};
    if (message.cvv !== undefined) {
      obj.cvv = message.cvv;
    }
    if (message.autoCapture !== undefined) {
      obj.autoCapture = message.autoCapture;
    }
    if (message.threeDsRequired !== undefined) {
      obj.threeDsRequired = message.threeDsRequired;
    }
    if (message.threeDsAllowUpgrade !== undefined) {
      obj.threeDsAllowUpgrade = message.threeDsAllowUpgrade;
    }
    return obj;
  },

  create(base?: DeepPartial<PaymentMethod_CardAuthorization>): PaymentMethod_CardAuthorization {
    return PaymentMethod_CardAuthorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaymentMethod_CardAuthorization>): PaymentMethod_CardAuthorization {
    const message = createBasePaymentMethod_CardAuthorization();
    message.cvv = object.cvv ?? undefined;
    message.autoCapture = object.autoCapture ?? undefined;
    message.threeDsRequired = object.threeDsRequired ?? undefined;
    message.threeDsAllowUpgrade = object.threeDsAllowUpgrade ?? undefined;
    return message;
  },
};

function createBaseCard(): Card {
  return {
    cardNumber: "",
    holderName: "",
    expiryMonth: 0,
    expiryYear: 0,
    billingAddress: undefined,
    bin: undefined,
    last4: undefined,
    scheme: undefined,
    type: undefined,
    issuer: undefined,
    issueCountry: undefined,
    productId: undefined,
    productType: undefined,
  };
}

export const Card: MessageFns<Card> = {
  encode(message: Card, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardNumber !== "") {
      writer.uint32(10).string(message.cardNumber);
    }
    if (message.holderName !== "") {
      writer.uint32(18).string(message.holderName);
    }
    if (message.expiryMonth !== 0) {
      writer.uint32(24).int32(message.expiryMonth);
    }
    if (message.expiryYear !== 0) {
      writer.uint32(32).int32(message.expiryYear);
    }
    if (message.billingAddress !== undefined) {
      Address.encode(message.billingAddress, writer.uint32(42).fork()).join();
    }
    if (message.bin !== undefined) {
      writer.uint32(50).string(message.bin);
    }
    if (message.last4 !== undefined) {
      writer.uint32(58).string(message.last4);
    }
    if (message.scheme !== undefined) {
      writer.uint32(66).string(message.scheme);
    }
    if (message.type !== undefined) {
      writer.uint32(74).string(message.type);
    }
    if (message.issuer !== undefined) {
      writer.uint32(82).string(message.issuer);
    }
    if (message.issueCountry !== undefined) {
      writer.uint32(90).string(message.issueCountry);
    }
    if (message.productId !== undefined) {
      writer.uint32(98).string(message.productId);
    }
    if (message.productType !== undefined) {
      writer.uint32(106).string(message.productType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.holderName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiryMonth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiryYear = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.billingAddress = Address.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bin = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.last4 = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.issueCountry = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.productType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card {
    return {
      cardNumber: isSet(object.cardNumber) ? globalThis.String(object.cardNumber) : "",
      holderName: isSet(object.holderName) ? globalThis.String(object.holderName) : "",
      expiryMonth: isSet(object.expiryMonth) ? globalThis.Number(object.expiryMonth) : 0,
      expiryYear: isSet(object.expiryYear) ? globalThis.Number(object.expiryYear) : 0,
      billingAddress: isSet(object.billingAddress) ? Address.fromJSON(object.billingAddress) : undefined,
      bin: isSet(object.bin) ? globalThis.String(object.bin) : undefined,
      last4: isSet(object.last4) ? globalThis.String(object.last4) : undefined,
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : undefined,
      issueCountry: isSet(object.issueCountry) ? globalThis.String(object.issueCountry) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : undefined,
      productType: isSet(object.productType) ? globalThis.String(object.productType) : undefined,
    };
  },

  toJSON(message: Card): unknown {
    const obj: any = {};
    if (message.cardNumber !== "") {
      obj.cardNumber = message.cardNumber;
    }
    if (message.holderName !== "") {
      obj.holderName = message.holderName;
    }
    if (message.expiryMonth !== 0) {
      obj.expiryMonth = Math.round(message.expiryMonth);
    }
    if (message.expiryYear !== 0) {
      obj.expiryYear = Math.round(message.expiryYear);
    }
    if (message.billingAddress !== undefined) {
      obj.billingAddress = Address.toJSON(message.billingAddress);
    }
    if (message.bin !== undefined) {
      obj.bin = message.bin;
    }
    if (message.last4 !== undefined) {
      obj.last4 = message.last4;
    }
    if (message.scheme !== undefined) {
      obj.scheme = message.scheme;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.issuer !== undefined) {
      obj.issuer = message.issuer;
    }
    if (message.issueCountry !== undefined) {
      obj.issueCountry = message.issueCountry;
    }
    if (message.productId !== undefined) {
      obj.productId = message.productId;
    }
    if (message.productType !== undefined) {
      obj.productType = message.productType;
    }
    return obj;
  },

  create(base?: DeepPartial<Card>): Card {
    return Card.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Card>): Card {
    const message = createBaseCard();
    message.cardNumber = object.cardNumber ?? "";
    message.holderName = object.holderName ?? "";
    message.expiryMonth = object.expiryMonth ?? 0;
    message.expiryYear = object.expiryYear ?? 0;
    message.billingAddress = (object.billingAddress !== undefined && object.billingAddress !== null)
      ? Address.fromPartial(object.billingAddress)
      : undefined;
    message.bin = object.bin ?? undefined;
    message.last4 = object.last4 ?? undefined;
    message.scheme = object.scheme ?? undefined;
    message.type = object.type ?? undefined;
    message.issuer = object.issuer ?? undefined;
    message.issueCountry = object.issueCountry ?? undefined;
    message.productId = object.productId ?? undefined;
    message.productType = object.productType ?? undefined;
    return message;
  },
};

function createBaseCardStats(): CardStats {
  return {
    cardId: "",
    channelId: "",
    supportsPayin: undefined,
    supportsPayout: undefined,
    supportsFastFunds: undefined,
    supportsCrossBoarderPayout: undefined,
    supportsCrossBoarderFastFunds: undefined,
    payinAttempts: 0,
    payinSuccesses: 0,
    payoutAttempts: 0,
    payoutSuccesses: 0,
    lastSuccessAt: undefined,
    lastFailedAt: undefined,
  };
}

export const CardStats: MessageFns<CardStats> = {
  encode(message: CardStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    if (message.supportsPayin !== undefined) {
      writer.uint32(24).bool(message.supportsPayin);
    }
    if (message.supportsPayout !== undefined) {
      writer.uint32(32).bool(message.supportsPayout);
    }
    if (message.supportsFastFunds !== undefined) {
      writer.uint32(40).bool(message.supportsFastFunds);
    }
    if (message.supportsCrossBoarderPayout !== undefined) {
      writer.uint32(48).bool(message.supportsCrossBoarderPayout);
    }
    if (message.supportsCrossBoarderFastFunds !== undefined) {
      writer.uint32(56).bool(message.supportsCrossBoarderFastFunds);
    }
    if (message.payinAttempts !== 0) {
      writer.uint32(64).int32(message.payinAttempts);
    }
    if (message.payinSuccesses !== 0) {
      writer.uint32(72).int32(message.payinSuccesses);
    }
    if (message.payoutAttempts !== 0) {
      writer.uint32(80).int32(message.payoutAttempts);
    }
    if (message.payoutSuccesses !== 0) {
      writer.uint32(88).int32(message.payoutSuccesses);
    }
    if (message.lastSuccessAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastSuccessAt), writer.uint32(98).fork()).join();
    }
    if (message.lastFailedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastFailedAt), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CardStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCardStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportsPayin = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.supportsPayout = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.supportsFastFunds = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.supportsCrossBoarderPayout = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.supportsCrossBoarderFastFunds = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.payinAttempts = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.payinSuccesses = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.payoutAttempts = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.payoutSuccesses = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.lastSuccessAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.lastFailedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CardStats {
    return {
      cardId: isSet(object.cardId) ? globalThis.String(object.cardId) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      supportsPayin: isSet(object.supportsPayin) ? globalThis.Boolean(object.supportsPayin) : undefined,
      supportsPayout: isSet(object.supportsPayout) ? globalThis.Boolean(object.supportsPayout) : undefined,
      supportsFastFunds: isSet(object.supportsFastFunds) ? globalThis.Boolean(object.supportsFastFunds) : undefined,
      supportsCrossBoarderPayout: isSet(object.supportsCrossBoarderPayout)
        ? globalThis.Boolean(object.supportsCrossBoarderPayout)
        : undefined,
      supportsCrossBoarderFastFunds: isSet(object.supportsCrossBoarderFastFunds)
        ? globalThis.Boolean(object.supportsCrossBoarderFastFunds)
        : undefined,
      payinAttempts: isSet(object.payinAttempts) ? globalThis.Number(object.payinAttempts) : 0,
      payinSuccesses: isSet(object.payinSuccesses) ? globalThis.Number(object.payinSuccesses) : 0,
      payoutAttempts: isSet(object.payoutAttempts) ? globalThis.Number(object.payoutAttempts) : 0,
      payoutSuccesses: isSet(object.payoutSuccesses) ? globalThis.Number(object.payoutSuccesses) : 0,
      lastSuccessAt: isSet(object.lastSuccessAt) ? fromJsonTimestamp(object.lastSuccessAt) : undefined,
      lastFailedAt: isSet(object.lastFailedAt) ? fromJsonTimestamp(object.lastFailedAt) : undefined,
    };
  },

  toJSON(message: CardStats): unknown {
    const obj: any = {};
    if (message.cardId !== "") {
      obj.cardId = message.cardId;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.supportsPayin !== undefined) {
      obj.supportsPayin = message.supportsPayin;
    }
    if (message.supportsPayout !== undefined) {
      obj.supportsPayout = message.supportsPayout;
    }
    if (message.supportsFastFunds !== undefined) {
      obj.supportsFastFunds = message.supportsFastFunds;
    }
    if (message.supportsCrossBoarderPayout !== undefined) {
      obj.supportsCrossBoarderPayout = message.supportsCrossBoarderPayout;
    }
    if (message.supportsCrossBoarderFastFunds !== undefined) {
      obj.supportsCrossBoarderFastFunds = message.supportsCrossBoarderFastFunds;
    }
    if (message.payinAttempts !== 0) {
      obj.payinAttempts = Math.round(message.payinAttempts);
    }
    if (message.payinSuccesses !== 0) {
      obj.payinSuccesses = Math.round(message.payinSuccesses);
    }
    if (message.payoutAttempts !== 0) {
      obj.payoutAttempts = Math.round(message.payoutAttempts);
    }
    if (message.payoutSuccesses !== 0) {
      obj.payoutSuccesses = Math.round(message.payoutSuccesses);
    }
    if (message.lastSuccessAt !== undefined) {
      obj.lastSuccessAt = message.lastSuccessAt.toISOString();
    }
    if (message.lastFailedAt !== undefined) {
      obj.lastFailedAt = message.lastFailedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CardStats>): CardStats {
    return CardStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CardStats>): CardStats {
    const message = createBaseCardStats();
    message.cardId = object.cardId ?? "";
    message.channelId = object.channelId ?? "";
    message.supportsPayin = object.supportsPayin ?? undefined;
    message.supportsPayout = object.supportsPayout ?? undefined;
    message.supportsFastFunds = object.supportsFastFunds ?? undefined;
    message.supportsCrossBoarderPayout = object.supportsCrossBoarderPayout ?? undefined;
    message.supportsCrossBoarderFastFunds = object.supportsCrossBoarderFastFunds ?? undefined;
    message.payinAttempts = object.payinAttempts ?? 0;
    message.payinSuccesses = object.payinSuccesses ?? 0;
    message.payoutAttempts = object.payoutAttempts ?? 0;
    message.payoutSuccesses = object.payoutSuccesses ?? 0;
    message.lastSuccessAt = object.lastSuccessAt ?? undefined;
    message.lastFailedAt = object.lastFailedAt ?? undefined;
    return message;
  },
};

function createBasePaymentData(): PaymentData {
  return { version: "", data: "", signature: "", header: undefined, decryptedData: undefined };
}

export const PaymentData: MessageFns<PaymentData> = {
  encode(message: PaymentData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.header !== undefined) {
      PaymentData_Header.encode(message.header, writer.uint32(34).fork()).join();
    }
    if (message.decryptedData !== undefined) {
      PaymentData_DecryptedData.encode(message.decryptedData, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.header = PaymentData_Header.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.decryptedData = PaymentData_DecryptedData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentData {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      header: isSet(object.header) ? PaymentData_Header.fromJSON(object.header) : undefined,
      decryptedData: isSet(object.decryptedData) ? PaymentData_DecryptedData.fromJSON(object.decryptedData) : undefined,
    };
  },

  toJSON(message: PaymentData): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.header !== undefined) {
      obj.header = PaymentData_Header.toJSON(message.header);
    }
    if (message.decryptedData !== undefined) {
      obj.decryptedData = PaymentData_DecryptedData.toJSON(message.decryptedData);
    }
    return obj;
  },

  create(base?: DeepPartial<PaymentData>): PaymentData {
    return PaymentData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaymentData>): PaymentData {
    const message = createBasePaymentData();
    message.version = object.version ?? "";
    message.data = object.data ?? "";
    message.signature = object.signature ?? "";
    message.header = (object.header !== undefined && object.header !== null)
      ? PaymentData_Header.fromPartial(object.header)
      : undefined;
    message.decryptedData = (object.decryptedData !== undefined && object.decryptedData !== null)
      ? PaymentData_DecryptedData.fromPartial(object.decryptedData)
      : undefined;
    return message;
  },
};

function createBasePaymentData_Header(): PaymentData_Header {
  return { ephemeralPublicKey: "", publicKeyHash: "", transactionId: "" };
}

export const PaymentData_Header: MessageFns<PaymentData_Header> = {
  encode(message: PaymentData_Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ephemeralPublicKey !== "") {
      writer.uint32(10).string(message.ephemeralPublicKey);
    }
    if (message.publicKeyHash !== "") {
      writer.uint32(18).string(message.publicKeyHash);
    }
    if (message.transactionId !== "") {
      writer.uint32(26).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentData_Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentData_Header();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ephemeralPublicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKeyHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentData_Header {
    return {
      ephemeralPublicKey: isSet(object.ephemeralPublicKey) ? globalThis.String(object.ephemeralPublicKey) : "",
      publicKeyHash: isSet(object.publicKeyHash) ? globalThis.String(object.publicKeyHash) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
    };
  },

  toJSON(message: PaymentData_Header): unknown {
    const obj: any = {};
    if (message.ephemeralPublicKey !== "") {
      obj.ephemeralPublicKey = message.ephemeralPublicKey;
    }
    if (message.publicKeyHash !== "") {
      obj.publicKeyHash = message.publicKeyHash;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create(base?: DeepPartial<PaymentData_Header>): PaymentData_Header {
    return PaymentData_Header.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaymentData_Header>): PaymentData_Header {
    const message = createBasePaymentData_Header();
    message.ephemeralPublicKey = object.ephemeralPublicKey ?? "";
    message.publicKeyHash = object.publicKeyHash ?? "";
    message.transactionId = object.transactionId ?? "";
    return message;
  },
};

function createBasePaymentData_DecryptedData(): PaymentData_DecryptedData {
  return {
    token: "",
    tokenFormat: "",
    holderName: "",
    bin: "",
    lastFour: "",
    expiryYear: 0,
    expiryMonth: 0,
    type: "",
    category: "",
    scheme: "",
    issuer: "",
    issueCountry: "",
    productId: "",
    productType: "",
    phone: "",
  };
}

export const PaymentData_DecryptedData: MessageFns<PaymentData_DecryptedData> = {
  encode(message: PaymentData_DecryptedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.tokenFormat !== "") {
      writer.uint32(18).string(message.tokenFormat);
    }
    if (message.holderName !== "") {
      writer.uint32(26).string(message.holderName);
    }
    if (message.bin !== "") {
      writer.uint32(34).string(message.bin);
    }
    if (message.lastFour !== "") {
      writer.uint32(42).string(message.lastFour);
    }
    if (message.expiryYear !== 0) {
      writer.uint32(48).int32(message.expiryYear);
    }
    if (message.expiryMonth !== 0) {
      writer.uint32(56).int32(message.expiryMonth);
    }
    if (message.type !== "") {
      writer.uint32(66).string(message.type);
    }
    if (message.category !== "") {
      writer.uint32(74).string(message.category);
    }
    if (message.scheme !== "") {
      writer.uint32(82).string(message.scheme);
    }
    if (message.issuer !== "") {
      writer.uint32(90).string(message.issuer);
    }
    if (message.issueCountry !== "") {
      writer.uint32(98).string(message.issueCountry);
    }
    if (message.productId !== "") {
      writer.uint32(106).string(message.productId);
    }
    if (message.productType !== "") {
      writer.uint32(114).string(message.productType);
    }
    if (message.phone !== "") {
      writer.uint32(122).string(message.phone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentData_DecryptedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentData_DecryptedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenFormat = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.holderName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastFour = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiryYear = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expiryMonth = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.issueCountry = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.productType = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentData_DecryptedData {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      tokenFormat: isSet(object.tokenFormat) ? globalThis.String(object.tokenFormat) : "",
      holderName: isSet(object.holderName) ? globalThis.String(object.holderName) : "",
      bin: isSet(object.bin) ? globalThis.String(object.bin) : "",
      lastFour: isSet(object.lastFour) ? globalThis.String(object.lastFour) : "",
      expiryYear: isSet(object.expiryYear) ? globalThis.Number(object.expiryYear) : 0,
      expiryMonth: isSet(object.expiryMonth) ? globalThis.Number(object.expiryMonth) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      issueCountry: isSet(object.issueCountry) ? globalThis.String(object.issueCountry) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      productType: isSet(object.productType) ? globalThis.String(object.productType) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
    };
  },

  toJSON(message: PaymentData_DecryptedData): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.tokenFormat !== "") {
      obj.tokenFormat = message.tokenFormat;
    }
    if (message.holderName !== "") {
      obj.holderName = message.holderName;
    }
    if (message.bin !== "") {
      obj.bin = message.bin;
    }
    if (message.lastFour !== "") {
      obj.lastFour = message.lastFour;
    }
    if (message.expiryYear !== 0) {
      obj.expiryYear = Math.round(message.expiryYear);
    }
    if (message.expiryMonth !== 0) {
      obj.expiryMonth = Math.round(message.expiryMonth);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.issueCountry !== "") {
      obj.issueCountry = message.issueCountry;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.productType !== "") {
      obj.productType = message.productType;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    return obj;
  },

  create(base?: DeepPartial<PaymentData_DecryptedData>): PaymentData_DecryptedData {
    return PaymentData_DecryptedData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaymentData_DecryptedData>): PaymentData_DecryptedData {
    const message = createBasePaymentData_DecryptedData();
    message.token = object.token ?? "";
    message.tokenFormat = object.tokenFormat ?? "";
    message.holderName = object.holderName ?? "";
    message.bin = object.bin ?? "";
    message.lastFour = object.lastFour ?? "";
    message.expiryYear = object.expiryYear ?? 0;
    message.expiryMonth = object.expiryMonth ?? 0;
    message.type = object.type ?? "";
    message.category = object.category ?? "";
    message.scheme = object.scheme ?? "";
    message.issuer = object.issuer ?? "";
    message.issueCountry = object.issueCountry ?? "";
    message.productId = object.productId ?? "";
    message.productType = object.productType ?? "";
    message.phone = object.phone ?? "";
    return message;
  },
};

function createBaseApplePay(): ApplePay {
  return {
    paymentData: undefined,
    billingAddress: undefined,
    email: undefined,
    phone: undefined,
    firstName: undefined,
    lastName: undefined,
  };
}

export const ApplePay: MessageFns<ApplePay> = {
  encode(message: ApplePay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentData !== undefined) {
      PaymentData.encode(message.paymentData, writer.uint32(10).fork()).join();
    }
    if (message.billingAddress !== undefined) {
      Address.encode(message.billingAddress, writer.uint32(26).fork()).join();
    }
    if (message.email !== undefined) {
      writer.uint32(34).string(message.email);
    }
    if (message.phone !== undefined) {
      writer.uint32(42).string(message.phone);
    }
    if (message.firstName !== undefined) {
      writer.uint32(50).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(58).string(message.lastName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplePay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplePay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentData = PaymentData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.billingAddress = Address.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplePay {
    return {
      paymentData: isSet(object.paymentData) ? PaymentData.fromJSON(object.paymentData) : undefined,
      billingAddress: isSet(object.billingAddress) ? Address.fromJSON(object.billingAddress) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
    };
  },

  toJSON(message: ApplePay): unknown {
    const obj: any = {};
    if (message.paymentData !== undefined) {
      obj.paymentData = PaymentData.toJSON(message.paymentData);
    }
    if (message.billingAddress !== undefined) {
      obj.billingAddress = Address.toJSON(message.billingAddress);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    return obj;
  },

  create(base?: DeepPartial<ApplePay>): ApplePay {
    return ApplePay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplePay>): ApplePay {
    const message = createBaseApplePay();
    message.paymentData = (object.paymentData !== undefined && object.paymentData !== null)
      ? PaymentData.fromPartial(object.paymentData)
      : undefined;
    message.billingAddress = (object.billingAddress !== undefined && object.billingAddress !== null)
      ? Address.fromPartial(object.billingAddress)
      : undefined;
    message.email = object.email ?? undefined;
    message.phone = object.phone ?? undefined;
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    return message;
  },
};

function createBaseMobileMoney(): MobileMoney {
  return {
    subType: "",
    network: undefined,
    phoneNumber: undefined,
    email: undefined,
    fullname: undefined,
    orderId: undefined,
    txRef: undefined,
    authorizationCode: undefined,
    country: undefined,
  };
}

export const MobileMoney: MessageFns<MobileMoney> = {
  encode(message: MobileMoney, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subType !== "") {
      writer.uint32(10).string(message.subType);
    }
    if (message.network !== undefined) {
      writer.uint32(18).string(message.network);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.email !== undefined) {
      writer.uint32(34).string(message.email);
    }
    if (message.fullname !== undefined) {
      writer.uint32(42).string(message.fullname);
    }
    if (message.orderId !== undefined) {
      writer.uint32(50).string(message.orderId);
    }
    if (message.txRef !== undefined) {
      writer.uint32(58).string(message.txRef);
    }
    if (message.authorizationCode !== undefined) {
      writer.uint32(66).string(message.authorizationCode);
    }
    if (message.country !== undefined) {
      writer.uint32(74).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MobileMoney {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMobileMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullname = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.txRef = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.authorizationCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MobileMoney {
    return {
      subType: isSet(object.subType) ? globalThis.String(object.subType) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      fullname: isSet(object.fullname) ? globalThis.String(object.fullname) : undefined,
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : undefined,
      txRef: isSet(object.txRef) ? globalThis.String(object.txRef) : undefined,
      authorizationCode: isSet(object.authorizationCode) ? globalThis.String(object.authorizationCode) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
    };
  },

  toJSON(message: MobileMoney): unknown {
    const obj: any = {};
    if (message.subType !== "") {
      obj.subType = message.subType;
    }
    if (message.network !== undefined) {
      obj.network = message.network;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.fullname !== undefined) {
      obj.fullname = message.fullname;
    }
    if (message.orderId !== undefined) {
      obj.orderId = message.orderId;
    }
    if (message.txRef !== undefined) {
      obj.txRef = message.txRef;
    }
    if (message.authorizationCode !== undefined) {
      obj.authorizationCode = message.authorizationCode;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    return obj;
  },

  create(base?: DeepPartial<MobileMoney>): MobileMoney {
    return MobileMoney.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MobileMoney>): MobileMoney {
    const message = createBaseMobileMoney();
    message.subType = object.subType ?? "";
    message.network = object.network ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.email = object.email ?? undefined;
    message.fullname = object.fullname ?? undefined;
    message.orderId = object.orderId ?? undefined;
    message.txRef = object.txRef ?? undefined;
    message.authorizationCode = object.authorizationCode ?? undefined;
    message.country = object.country ?? undefined;
    return message;
  },
};

function createBaseBankAccount(): BankAccount {
  return {
    accountNumber: undefined,
    accountExpiration: undefined,
    bankCode: undefined,
    bankCountry: undefined,
    bankName: undefined,
    routingNumber: undefined,
    sortCode: undefined,
    swiftCode: undefined,
    accountName: undefined,
  };
}

export const BankAccount: MessageFns<BankAccount> = {
  encode(message: BankAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountNumber !== undefined) {
      writer.uint32(10).string(message.accountNumber);
    }
    if (message.accountExpiration !== undefined) {
      writer.uint32(18).string(message.accountExpiration);
    }
    if (message.bankCode !== undefined) {
      writer.uint32(26).string(message.bankCode);
    }
    if (message.bankCountry !== undefined) {
      writer.uint32(34).string(message.bankCountry);
    }
    if (message.bankName !== undefined) {
      writer.uint32(42).string(message.bankName);
    }
    if (message.routingNumber !== undefined) {
      writer.uint32(50).string(message.routingNumber);
    }
    if (message.sortCode !== undefined) {
      writer.uint32(58).string(message.sortCode);
    }
    if (message.swiftCode !== undefined) {
      writer.uint32(66).string(message.swiftCode);
    }
    if (message.accountName !== undefined) {
      writer.uint32(74).string(message.accountName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountExpiration = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bankCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bankCountry = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.routingNumber = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sortCode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.swiftCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.accountName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankAccount {
    return {
      accountNumber: isSet(object.accountNumber) ? globalThis.String(object.accountNumber) : undefined,
      accountExpiration: isSet(object.accountExpiration) ? globalThis.String(object.accountExpiration) : undefined,
      bankCode: isSet(object.bankCode) ? globalThis.String(object.bankCode) : undefined,
      bankCountry: isSet(object.bankCountry) ? globalThis.String(object.bankCountry) : undefined,
      bankName: isSet(object.bankName) ? globalThis.String(object.bankName) : undefined,
      routingNumber: isSet(object.routingNumber) ? globalThis.String(object.routingNumber) : undefined,
      sortCode: isSet(object.sortCode) ? globalThis.String(object.sortCode) : undefined,
      swiftCode: isSet(object.swiftCode) ? globalThis.String(object.swiftCode) : undefined,
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : undefined,
    };
  },

  toJSON(message: BankAccount): unknown {
    const obj: any = {};
    if (message.accountNumber !== undefined) {
      obj.accountNumber = message.accountNumber;
    }
    if (message.accountExpiration !== undefined) {
      obj.accountExpiration = message.accountExpiration;
    }
    if (message.bankCode !== undefined) {
      obj.bankCode = message.bankCode;
    }
    if (message.bankCountry !== undefined) {
      obj.bankCountry = message.bankCountry;
    }
    if (message.bankName !== undefined) {
      obj.bankName = message.bankName;
    }
    if (message.routingNumber !== undefined) {
      obj.routingNumber = message.routingNumber;
    }
    if (message.sortCode !== undefined) {
      obj.sortCode = message.sortCode;
    }
    if (message.swiftCode !== undefined) {
      obj.swiftCode = message.swiftCode;
    }
    if (message.accountName !== undefined) {
      obj.accountName = message.accountName;
    }
    return obj;
  },

  create(base?: DeepPartial<BankAccount>): BankAccount {
    return BankAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BankAccount>): BankAccount {
    const message = createBaseBankAccount();
    message.accountNumber = object.accountNumber ?? undefined;
    message.accountExpiration = object.accountExpiration ?? undefined;
    message.bankCode = object.bankCode ?? undefined;
    message.bankCountry = object.bankCountry ?? undefined;
    message.bankName = object.bankName ?? undefined;
    message.routingNumber = object.routingNumber ?? undefined;
    message.sortCode = object.sortCode ?? undefined;
    message.swiftCode = object.swiftCode ?? undefined;
    message.accountName = object.accountName ?? undefined;
    return message;
  },
};

function createBaseBankTransfer(): BankTransfer {
  return { accountNumber: undefined, fullname: undefined, phoneNumber: undefined, email: undefined };
}

export const BankTransfer: MessageFns<BankTransfer> = {
  encode(message: BankTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountNumber !== undefined) {
      writer.uint32(10).string(message.accountNumber);
    }
    if (message.fullname !== undefined) {
      writer.uint32(18).string(message.fullname);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.email !== undefined) {
      writer.uint32(34).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fullname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankTransfer {
    return {
      accountNumber: isSet(object.accountNumber) ? globalThis.String(object.accountNumber) : undefined,
      fullname: isSet(object.fullname) ? globalThis.String(object.fullname) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
    };
  },

  toJSON(message: BankTransfer): unknown {
    const obj: any = {};
    if (message.accountNumber !== undefined) {
      obj.accountNumber = message.accountNumber;
    }
    if (message.fullname !== undefined) {
      obj.fullname = message.fullname;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<BankTransfer>): BankTransfer {
    return BankTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BankTransfer>): BankTransfer {
    const message = createBaseBankTransfer();
    message.accountNumber = object.accountNumber ?? undefined;
    message.fullname = object.fullname ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.email = object.email ?? undefined;
    return message;
  },
};

function createBaseOpenBanking(): OpenBanking {
  return {
    provider: undefined,
    bankId: undefined,
    country: undefined,
    accountNumber: undefined,
    fullname: undefined,
    phoneNumber: undefined,
    email: undefined,
  };
}

export const OpenBanking: MessageFns<OpenBanking> = {
  encode(message: OpenBanking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== undefined) {
      writer.uint32(10).string(message.provider);
    }
    if (message.bankId !== undefined) {
      writer.uint32(18).string(message.bankId);
    }
    if (message.country !== undefined) {
      writer.uint32(26).string(message.country);
    }
    if (message.accountNumber !== undefined) {
      writer.uint32(34).string(message.accountNumber);
    }
    if (message.fullname !== undefined) {
      writer.uint32(42).string(message.fullname);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(50).string(message.phoneNumber);
    }
    if (message.email !== undefined) {
      writer.uint32(58).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenBanking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenBanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bankId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accountNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullname = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenBanking {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : undefined,
      bankId: isSet(object.bankId) ? globalThis.String(object.bankId) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      accountNumber: isSet(object.accountNumber) ? globalThis.String(object.accountNumber) : undefined,
      fullname: isSet(object.fullname) ? globalThis.String(object.fullname) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
    };
  },

  toJSON(message: OpenBanking): unknown {
    const obj: any = {};
    if (message.provider !== undefined) {
      obj.provider = message.provider;
    }
    if (message.bankId !== undefined) {
      obj.bankId = message.bankId;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.accountNumber !== undefined) {
      obj.accountNumber = message.accountNumber;
    }
    if (message.fullname !== undefined) {
      obj.fullname = message.fullname;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<OpenBanking>): OpenBanking {
    return OpenBanking.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OpenBanking>): OpenBanking {
    const message = createBaseOpenBanking();
    message.provider = object.provider ?? undefined;
    message.bankId = object.bankId ?? undefined;
    message.country = object.country ?? undefined;
    message.accountNumber = object.accountNumber ?? undefined;
    message.fullname = object.fullname ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.email = object.email ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
