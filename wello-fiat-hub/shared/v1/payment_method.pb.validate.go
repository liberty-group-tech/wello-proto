// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: wello-fiat-hub/shared/v1/payment_method.proto

package shared

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PaymentMethod with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentMethod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentMethod with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PaymentMethodMultiError, or
// nil if none found.
func (m *PaymentMethod) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentMethod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Method.(type) {
	case *PaymentMethod_Card:
		if v == nil {
			err := PaymentMethodValidationError{
				field:  "Method",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "Card",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "Card",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentMethodValidationError{
					field:  "Card",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PaymentMethod_MobileMoney:
		if v == nil {
			err := PaymentMethodValidationError{
				field:  "Method",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMobileMoney()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "MobileMoney",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "MobileMoney",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMobileMoney()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentMethodValidationError{
					field:  "MobileMoney",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PaymentMethod_BankAccount:
		if v == nil {
			err := PaymentMethodValidationError{
				field:  "Method",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBankAccount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "BankAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "BankAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentMethodValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PaymentMethod_BankTransfer:
		if v == nil {
			err := PaymentMethodValidationError{
				field:  "Method",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBankTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "BankTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "BankTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBankTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentMethodValidationError{
					field:  "BankTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PaymentMethod_ApplePay:
		if v == nil {
			err := PaymentMethodValidationError{
				field:  "Method",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplePay()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "ApplePay",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "ApplePay",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplePay()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentMethodValidationError{
					field:  "ApplePay",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PaymentMethod_OpenBanking:
		if v == nil {
			err := PaymentMethodValidationError{
				field:  "Method",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOpenBanking()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "OpenBanking",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "OpenBanking",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpenBanking()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentMethodValidationError{
					field:  "OpenBanking",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Authorization.(type) {
	case *PaymentMethod_CardAuthorization_:
		if v == nil {
			err := PaymentMethodValidationError{
				field:  "Authorization",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCardAuthorization()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "CardAuthorization",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentMethodValidationError{
						field:  "CardAuthorization",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCardAuthorization()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentMethodValidationError{
					field:  "CardAuthorization",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.Id != nil {

		if !strings.HasPrefix(m.GetId(), "pm_") {
			err := PaymentMethodValidationError{
				field:  "Id",
				reason: "value does not have prefix \"pm_\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Store != nil {
		// no validation rules for Store
	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if len(errors) > 0 {
		return PaymentMethodMultiError(errors)
	}

	return nil
}

// PaymentMethodMultiError is an error wrapping multiple validation errors
// returned by PaymentMethod.ValidateAll() if the designated constraints
// aren't met.
type PaymentMethodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentMethodMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentMethodMultiError) AllErrors() []error { return m }

// PaymentMethodValidationError is the validation error returned by
// PaymentMethod.Validate if the designated constraints aren't met.
type PaymentMethodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentMethodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentMethodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentMethodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentMethodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentMethodValidationError) ErrorName() string { return "PaymentMethodValidationError" }

// Error satisfies the builtin error interface
func (e PaymentMethodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentMethod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentMethodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentMethodValidationError{}

// Validate checks the field values on Card with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Card) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Card with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CardMultiError, or nil if none found.
func (m *Card) ValidateAll() error {
	return m.validate(true)
}

func (m *Card) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CardNumber

	// no validation rules for HolderName

	if m.GetExpiryMonth() != 0 {

		if val := m.GetExpiryMonth(); val <= 0 || val >= 13 {
			err := CardValidationError{
				field:  "ExpiryMonth",
				reason: "value must be inside range (0, 13)",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetExpiryYear() != 0 {

		if m.GetExpiryYear() < 2025 {
			err := CardValidationError{
				field:  "ExpiryYear",
				reason: "value must be greater than or equal to 2025",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.BillingAddress != nil {

		if all {
			switch v := interface{}(m.GetBillingAddress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CardValidationError{
						field:  "BillingAddress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CardValidationError{
						field:  "BillingAddress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBillingAddress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CardValidationError{
					field:  "BillingAddress",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Bin != nil {
		// no validation rules for Bin
	}

	if m.Last4 != nil {
		// no validation rules for Last4
	}

	if m.Scheme != nil {
		// no validation rules for Scheme
	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Issuer != nil {
		// no validation rules for Issuer
	}

	if m.IssueCountry != nil {

		if !_Card_IssueCountry_Pattern.MatchString(m.GetIssueCountry()) {
			err := CardValidationError{
				field:  "IssueCountry",
				reason: "value does not match regex pattern \"^[A-Z]{2}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ProductId != nil {
		// no validation rules for ProductId
	}

	if m.ProductType != nil {
		// no validation rules for ProductType
	}

	if len(errors) > 0 {
		return CardMultiError(errors)
	}

	return nil
}

// CardMultiError is an error wrapping multiple validation errors returned by
// Card.ValidateAll() if the designated constraints aren't met.
type CardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardMultiError) AllErrors() []error { return m }

// CardValidationError is the validation error returned by Card.Validate if the
// designated constraints aren't met.
type CardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardValidationError) ErrorName() string { return "CardValidationError" }

// Error satisfies the builtin error interface
func (e CardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardValidationError{}

var _Card_IssueCountry_Pattern = regexp.MustCompile("^[A-Z]{2}$")

// Validate checks the field values on CardStats with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CardStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardStats with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CardStatsMultiError, or nil
// if none found.
func (m *CardStats) ValidateAll() error {
	return m.validate(true)
}

func (m *CardStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetCardId(), "card_") {
		err := CardStatsValidationError{
			field:  "CardId",
			reason: "value does not have prefix \"card_\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ChannelId

	// no validation rules for PayinAttempts

	// no validation rules for PayinSuccesses

	// no validation rules for PayoutAttempts

	// no validation rules for PayoutSuccesses

	if all {
		switch v := interface{}(m.GetLastSuccessAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardStatsValidationError{
					field:  "LastSuccessAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardStatsValidationError{
					field:  "LastSuccessAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastSuccessAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardStatsValidationError{
				field:  "LastSuccessAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastFailedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardStatsValidationError{
					field:  "LastFailedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardStatsValidationError{
					field:  "LastFailedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastFailedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardStatsValidationError{
				field:  "LastFailedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.SupportsPayin != nil {
		// no validation rules for SupportsPayin
	}

	if m.SupportsPayout != nil {
		// no validation rules for SupportsPayout
	}

	if m.SupportsFastFunds != nil {
		// no validation rules for SupportsFastFunds
	}

	if m.SupportsCrossBoarderPayout != nil {
		// no validation rules for SupportsCrossBoarderPayout
	}

	if m.SupportsCrossBoarderFastFunds != nil {
		// no validation rules for SupportsCrossBoarderFastFunds
	}

	if len(errors) > 0 {
		return CardStatsMultiError(errors)
	}

	return nil
}

// CardStatsMultiError is an error wrapping multiple validation errors returned
// by CardStats.ValidateAll() if the designated constraints aren't met.
type CardStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardStatsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardStatsMultiError) AllErrors() []error { return m }

// CardStatsValidationError is the validation error returned by
// CardStats.Validate if the designated constraints aren't met.
type CardStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardStatsValidationError) ErrorName() string { return "CardStatsValidationError" }

// Error satisfies the builtin error interface
func (e CardStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardStatsValidationError{}

// Validate checks the field values on PaymentData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PaymentDataMultiError, or
// nil if none found.
func (m *PaymentData) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _PaymentData_Version_InLookup[m.GetVersion()]; !ok {
		err := PaymentDataValidationError{
			field:  "Version",
			reason: "value must be in list [RSA_v1 EC_v1 EC_v2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetData()) < 1 {
		err := PaymentDataValidationError{
			field:  "Data",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSignature()) < 1 {
		err := PaymentDataValidationError{
			field:  "Signature",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetHeader() == nil {
		err := PaymentDataValidationError{
			field:  "Header",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentDataValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentDataValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentDataValidationError{
				field:  "Header",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.DecryptedData != nil {

		if all {
			switch v := interface{}(m.GetDecryptedData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentDataValidationError{
						field:  "DecryptedData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentDataValidationError{
						field:  "DecryptedData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDecryptedData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentDataValidationError{
					field:  "DecryptedData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PaymentDataMultiError(errors)
	}

	return nil
}

// PaymentDataMultiError is an error wrapping multiple validation errors
// returned by PaymentData.ValidateAll() if the designated constraints aren't met.
type PaymentDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentDataMultiError) AllErrors() []error { return m }

// PaymentDataValidationError is the validation error returned by
// PaymentData.Validate if the designated constraints aren't met.
type PaymentDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentDataValidationError) ErrorName() string { return "PaymentDataValidationError" }

// Error satisfies the builtin error interface
func (e PaymentDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentDataValidationError{}

var _PaymentData_Version_InLookup = map[string]struct{}{
	"RSA_v1": {},
	"EC_v1":  {},
	"EC_v2":  {},
}

// Validate checks the field values on ApplePay with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApplePay) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplePay with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplePayMultiError, or nil
// if none found.
func (m *ApplePay) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplePay) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPaymentData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplePayValidationError{
					field:  "PaymentData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplePayValidationError{
					field:  "PaymentData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplePayValidationError{
				field:  "PaymentData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.BillingAddress != nil {

		if all {
			switch v := interface{}(m.GetBillingAddress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplePayValidationError{
						field:  "BillingAddress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplePayValidationError{
						field:  "BillingAddress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBillingAddress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplePayValidationError{
					field:  "BillingAddress",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = ApplePayValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Phone != nil {

		if !_ApplePay_Phone_Pattern.MatchString(m.GetPhone()) {
			err := ApplePayValidationError{
				field:  "Phone",
				reason: "value does not match regex pattern \"^\\\\+?\\\\d(?:[\\\\d\\\\s\\\\-\\\\(\\\\)]{6,19})$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.FirstName != nil {
		// no validation rules for FirstName
	}

	if m.LastName != nil {
		// no validation rules for LastName
	}

	if len(errors) > 0 {
		return ApplePayMultiError(errors)
	}

	return nil
}

func (m *ApplePay) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *ApplePay) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// ApplePayMultiError is an error wrapping multiple validation errors returned
// by ApplePay.ValidateAll() if the designated constraints aren't met.
type ApplePayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplePayMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplePayMultiError) AllErrors() []error { return m }

// ApplePayValidationError is the validation error returned by
// ApplePay.Validate if the designated constraints aren't met.
type ApplePayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplePayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplePayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplePayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplePayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplePayValidationError) ErrorName() string { return "ApplePayValidationError" }

// Error satisfies the builtin error interface
func (e ApplePayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplePay.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplePayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplePayValidationError{}

var _ApplePay_Phone_Pattern = regexp.MustCompile("^\\+?\\d(?:[\\d\\s\\-\\(\\)]{6,19})$")

// Validate checks the field values on MobileMoney with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MobileMoney) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MobileMoney with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MobileMoneyMultiError, or
// nil if none found.
func (m *MobileMoney) ValidateAll() error {
	return m.validate(true)
}

func (m *MobileMoney) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _MobileMoney_SubType_InLookup[m.GetSubType()]; !ok {
		err := MobileMoneyValidationError{
			field:  "SubType",
			reason: "value must be in list [mobile_money_franco mobile_money_ghana mobile_money_uganda mobile_money_tanzania mobile_money_zambia mobile_money_rwanda mpesa]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Network != nil {
		// no validation rules for Network
	}

	if m.PhoneNumber != nil {

		if !_MobileMoney_PhoneNumber_Pattern.MatchString(m.GetPhoneNumber()) {
			err := MobileMoneyValidationError{
				field:  "PhoneNumber",
				reason: "value does not match regex pattern \"^\\\\+?\\\\d(?:[\\\\d\\\\s\\\\-\\\\(\\\\)]{6,19})$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = MobileMoneyValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Fullname != nil {
		// no validation rules for Fullname
	}

	if m.OrderId != nil {
		// no validation rules for OrderId
	}

	if m.TxRef != nil {
		// no validation rules for TxRef
	}

	if m.AuthorizationCode != nil {
		// no validation rules for AuthorizationCode
	}

	if m.Country != nil {

		if !_MobileMoney_Country_Pattern.MatchString(m.GetCountry()) {
			err := MobileMoneyValidationError{
				field:  "Country",
				reason: "value does not match regex pattern \"^[A-Z]{2}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return MobileMoneyMultiError(errors)
	}

	return nil
}

func (m *MobileMoney) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *MobileMoney) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// MobileMoneyMultiError is an error wrapping multiple validation errors
// returned by MobileMoney.ValidateAll() if the designated constraints aren't met.
type MobileMoneyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MobileMoneyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MobileMoneyMultiError) AllErrors() []error { return m }

// MobileMoneyValidationError is the validation error returned by
// MobileMoney.Validate if the designated constraints aren't met.
type MobileMoneyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MobileMoneyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MobileMoneyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MobileMoneyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MobileMoneyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MobileMoneyValidationError) ErrorName() string { return "MobileMoneyValidationError" }

// Error satisfies the builtin error interface
func (e MobileMoneyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMobileMoney.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MobileMoneyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MobileMoneyValidationError{}

var _MobileMoney_SubType_InLookup = map[string]struct{}{
	"mobile_money_franco":   {},
	"mobile_money_ghana":    {},
	"mobile_money_uganda":   {},
	"mobile_money_tanzania": {},
	"mobile_money_zambia":   {},
	"mobile_money_rwanda":   {},
	"mpesa":                 {},
}

var _MobileMoney_PhoneNumber_Pattern = regexp.MustCompile("^\\+?\\d(?:[\\d\\s\\-\\(\\)]{6,19})$")

var _MobileMoney_Country_Pattern = regexp.MustCompile("^[A-Z]{2}$")

// Validate checks the field values on BankAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BankAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BankAccountMultiError, or
// nil if none found.
func (m *BankAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *BankAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.AccountNumber != nil {
		// no validation rules for AccountNumber
	}

	if m.AccountExpiration != nil {
		// no validation rules for AccountExpiration
	}

	if m.BankCode != nil {
		// no validation rules for BankCode
	}

	if m.BankCountry != nil {

		if !_BankAccount_BankCountry_Pattern.MatchString(m.GetBankCountry()) {
			err := BankAccountValidationError{
				field:  "BankCountry",
				reason: "value does not match regex pattern \"^[A-Z]{2}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.BankName != nil {
		// no validation rules for BankName
	}

	if m.RoutingNumber != nil {
		// no validation rules for RoutingNumber
	}

	if m.SortCode != nil {
		// no validation rules for SortCode
	}

	if m.SwiftCode != nil {
		// no validation rules for SwiftCode
	}

	if m.AccountName != nil {
		// no validation rules for AccountName
	}

	if len(errors) > 0 {
		return BankAccountMultiError(errors)
	}

	return nil
}

// BankAccountMultiError is an error wrapping multiple validation errors
// returned by BankAccount.ValidateAll() if the designated constraints aren't met.
type BankAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankAccountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankAccountMultiError) AllErrors() []error { return m }

// BankAccountValidationError is the validation error returned by
// BankAccount.Validate if the designated constraints aren't met.
type BankAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankAccountValidationError) ErrorName() string { return "BankAccountValidationError" }

// Error satisfies the builtin error interface
func (e BankAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankAccountValidationError{}

var _BankAccount_BankCountry_Pattern = regexp.MustCompile("^[A-Z]{2}$")

// Validate checks the field values on BankTransfer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BankTransfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankTransfer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BankTransferMultiError, or
// nil if none found.
func (m *BankTransfer) ValidateAll() error {
	return m.validate(true)
}

func (m *BankTransfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.AccountNumber != nil {
		// no validation rules for AccountNumber
	}

	if m.Fullname != nil {
		// no validation rules for Fullname
	}

	if m.PhoneNumber != nil {

		if !_BankTransfer_PhoneNumber_Pattern.MatchString(m.GetPhoneNumber()) {
			err := BankTransferValidationError{
				field:  "PhoneNumber",
				reason: "value does not match regex pattern \"^\\\\+?\\\\d(?:[\\\\d\\\\s\\\\-\\\\(\\\\)]{6,19})$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = BankTransferValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return BankTransferMultiError(errors)
	}

	return nil
}

func (m *BankTransfer) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *BankTransfer) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// BankTransferMultiError is an error wrapping multiple validation errors
// returned by BankTransfer.ValidateAll() if the designated constraints aren't met.
type BankTransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankTransferMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankTransferMultiError) AllErrors() []error { return m }

// BankTransferValidationError is the validation error returned by
// BankTransfer.Validate if the designated constraints aren't met.
type BankTransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankTransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankTransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankTransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankTransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankTransferValidationError) ErrorName() string { return "BankTransferValidationError" }

// Error satisfies the builtin error interface
func (e BankTransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankTransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankTransferValidationError{}

var _BankTransfer_PhoneNumber_Pattern = regexp.MustCompile("^\\+?\\d(?:[\\d\\s\\-\\(\\)]{6,19})$")

// Validate checks the field values on OpenBanking with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenBanking) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenBanking with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenBankingMultiError, or
// nil if none found.
func (m *OpenBanking) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenBanking) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Provider != nil {
		// no validation rules for Provider
	}

	if m.BankId != nil {
		// no validation rules for BankId
	}

	if m.Country != nil {

		if !_OpenBanking_Country_Pattern.MatchString(m.GetCountry()) {
			err := OpenBankingValidationError{
				field:  "Country",
				reason: "value does not match regex pattern \"^[A-Z]{2}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.AccountNumber != nil {
		// no validation rules for AccountNumber
	}

	if m.Fullname != nil {
		// no validation rules for Fullname
	}

	if m.PhoneNumber != nil {

		if !_OpenBanking_PhoneNumber_Pattern.MatchString(m.GetPhoneNumber()) {
			err := OpenBankingValidationError{
				field:  "PhoneNumber",
				reason: "value does not match regex pattern \"^\\\\+?\\\\d(?:[\\\\d\\\\s\\\\-\\\\(\\\\)]{6,19})$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = OpenBankingValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return OpenBankingMultiError(errors)
	}

	return nil
}

func (m *OpenBanking) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *OpenBanking) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// OpenBankingMultiError is an error wrapping multiple validation errors
// returned by OpenBanking.ValidateAll() if the designated constraints aren't met.
type OpenBankingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenBankingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenBankingMultiError) AllErrors() []error { return m }

// OpenBankingValidationError is the validation error returned by
// OpenBanking.Validate if the designated constraints aren't met.
type OpenBankingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenBankingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenBankingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenBankingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenBankingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenBankingValidationError) ErrorName() string { return "OpenBankingValidationError" }

// Error satisfies the builtin error interface
func (e OpenBankingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenBanking.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenBankingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenBankingValidationError{}

var _OpenBanking_Country_Pattern = regexp.MustCompile("^[A-Z]{2}$")

var _OpenBanking_PhoneNumber_Pattern = regexp.MustCompile("^\\+?\\d(?:[\\d\\s\\-\\(\\)]{6,19})$")

// Validate checks the field values on PaymentMethod_CardAuthorization with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PaymentMethod_CardAuthorization) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentMethod_CardAuthorization with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PaymentMethod_CardAuthorizationMultiError, or nil if none found.
func (m *PaymentMethod_CardAuthorization) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentMethod_CardAuthorization) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Cvv != nil {

		if utf8.RuneCountInString(m.GetCvv()) != 3 {
			err := PaymentMethod_CardAuthorizationValidationError{
				field:  "Cvv",
				reason: "value length must be 3 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)

		}

	}

	if m.AutoCapture != nil {
		// no validation rules for AutoCapture
	}

	if m.ThreeDsRequired != nil {
		// no validation rules for ThreeDsRequired
	}

	if m.ThreeDsAllowUpgrade != nil {
		// no validation rules for ThreeDsAllowUpgrade
	}

	if len(errors) > 0 {
		return PaymentMethod_CardAuthorizationMultiError(errors)
	}

	return nil
}

// PaymentMethod_CardAuthorizationMultiError is an error wrapping multiple
// validation errors returned by PaymentMethod_CardAuthorization.ValidateAll()
// if the designated constraints aren't met.
type PaymentMethod_CardAuthorizationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentMethod_CardAuthorizationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentMethod_CardAuthorizationMultiError) AllErrors() []error { return m }

// PaymentMethod_CardAuthorizationValidationError is the validation error
// returned by PaymentMethod_CardAuthorization.Validate if the designated
// constraints aren't met.
type PaymentMethod_CardAuthorizationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentMethod_CardAuthorizationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentMethod_CardAuthorizationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentMethod_CardAuthorizationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentMethod_CardAuthorizationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentMethod_CardAuthorizationValidationError) ErrorName() string {
	return "PaymentMethod_CardAuthorizationValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentMethod_CardAuthorizationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentMethod_CardAuthorization.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentMethod_CardAuthorizationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentMethod_CardAuthorizationValidationError{}

// Validate checks the field values on PaymentData_Header with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PaymentData_Header) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentData_Header with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaymentData_HeaderMultiError, or nil if none found.
func (m *PaymentData_Header) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentData_Header) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EphemeralPublicKey

	// no validation rules for PublicKeyHash

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return PaymentData_HeaderMultiError(errors)
	}

	return nil
}

// PaymentData_HeaderMultiError is an error wrapping multiple validation errors
// returned by PaymentData_Header.ValidateAll() if the designated constraints
// aren't met.
type PaymentData_HeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentData_HeaderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentData_HeaderMultiError) AllErrors() []error { return m }

// PaymentData_HeaderValidationError is the validation error returned by
// PaymentData_Header.Validate if the designated constraints aren't met.
type PaymentData_HeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentData_HeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentData_HeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentData_HeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentData_HeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentData_HeaderValidationError) ErrorName() string {
	return "PaymentData_HeaderValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentData_HeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentData_Header.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentData_HeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentData_HeaderValidationError{}

// Validate checks the field values on PaymentData_DecryptedData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PaymentData_DecryptedData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentData_DecryptedData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaymentData_DecryptedDataMultiError, or nil if none found.
func (m *PaymentData_DecryptedData) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentData_DecryptedData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for TokenFormat

	// no validation rules for HolderName

	// no validation rules for Bin

	// no validation rules for LastFour

	// no validation rules for ExpiryYear

	// no validation rules for ExpiryMonth

	// no validation rules for Type

	// no validation rules for Category

	// no validation rules for Scheme

	// no validation rules for Issuer

	// no validation rules for IssueCountry

	// no validation rules for ProductId

	// no validation rules for ProductType

	// no validation rules for Phone

	if len(errors) > 0 {
		return PaymentData_DecryptedDataMultiError(errors)
	}

	return nil
}

// PaymentData_DecryptedDataMultiError is an error wrapping multiple validation
// errors returned by PaymentData_DecryptedData.ValidateAll() if the
// designated constraints aren't met.
type PaymentData_DecryptedDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentData_DecryptedDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentData_DecryptedDataMultiError) AllErrors() []error { return m }

// PaymentData_DecryptedDataValidationError is the validation error returned by
// PaymentData_DecryptedData.Validate if the designated constraints aren't met.
type PaymentData_DecryptedDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentData_DecryptedDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentData_DecryptedDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentData_DecryptedDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentData_DecryptedDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentData_DecryptedDataValidationError) ErrorName() string {
	return "PaymentData_DecryptedDataValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentData_DecryptedDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentData_DecryptedData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentData_DecryptedDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentData_DecryptedDataValidationError{}
