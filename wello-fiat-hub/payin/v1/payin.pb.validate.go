// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: wello-fiat-hub/payin/v1/payin.proto

package payin

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PayRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayRequestMultiError, or
// nil if none found.
func (m *PayRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PayRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelId

	if !_PayRequest_Amount_Pattern.MatchString(m.GetAmount()) {
		err := PayRequestValidationError{
			field:  "Amount",
			reason: "value does not match regex pattern \"^[0-9]+(\\\\.[0-9]+)?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PayRequest_Currency_Pattern.MatchString(m.GetCurrency()) {
		err := PayRequestValidationError{
			field:  "Currency",
			reason: "value does not match regex pattern \"^[A-Z]{3}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPaymentMethod() == nil {
		err := PayRequestValidationError{
			field:  "PaymentMethod",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPaymentMethod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayRequestValidationError{
					field:  "PaymentMethod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayRequestValidationError{
					field:  "PaymentMethod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentMethod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayRequestValidationError{
				field:  "PaymentMethod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.ReferenceId != nil {
		// no validation rules for ReferenceId
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Identity != nil {

		if all {
			switch v := interface{}(m.GetIdentity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayRequestValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayRequestValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIdentity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayRequestValidationError{
					field:  "Identity",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Fingerprint != nil {

		if all {
			switch v := interface{}(m.GetFingerprint()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayRequestValidationError{
						field:  "Fingerprint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayRequestValidationError{
						field:  "Fingerprint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFingerprint()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayRequestValidationError{
					field:  "Fingerprint",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Callback != nil {

		if all {
			switch v := interface{}(m.GetCallback()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayRequestValidationError{
						field:  "Callback",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayRequestValidationError{
						field:  "Callback",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCallback()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayRequestValidationError{
					field:  "Callback",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PayRequestMultiError(errors)
	}

	return nil
}

// PayRequestMultiError is an error wrapping multiple validation errors
// returned by PayRequest.ValidateAll() if the designated constraints aren't met.
type PayRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayRequestMultiError) AllErrors() []error { return m }

// PayRequestValidationError is the validation error returned by
// PayRequest.Validate if the designated constraints aren't met.
type PayRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayRequestValidationError) ErrorName() string { return "PayRequestValidationError" }

// Error satisfies the builtin error interface
func (e PayRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayRequestValidationError{}

var _PayRequest_Amount_Pattern = regexp.MustCompile("^[0-9]+(\\.[0-9]+)?$")

var _PayRequest_Currency_Pattern = regexp.MustCompile("^[A-Z]{3}$")

// Validate checks the field values on Callback with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Callback) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Callback with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CallbackMultiError, or nil
// if none found.
func (m *Callback) ValidateAll() error {
	return m.validate(true)
}

func (m *Callback) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.SuccessUrl != nil {

		if uri, err := url.Parse(m.GetSuccessUrl()); err != nil {
			err = CallbackValidationError{
				field:  "SuccessUrl",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := CallbackValidationError{
				field:  "SuccessUrl",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.FailureUrl != nil {

		if uri, err := url.Parse(m.GetFailureUrl()); err != nil {
			err = CallbackValidationError{
				field:  "FailureUrl",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := CallbackValidationError{
				field:  "FailureUrl",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.WebhookUrl != nil {

		if uri, err := url.Parse(m.GetWebhookUrl()); err != nil {
			err = CallbackValidationError{
				field:  "WebhookUrl",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := CallbackValidationError{
				field:  "WebhookUrl",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CallbackMultiError(errors)
	}

	return nil
}

// CallbackMultiError is an error wrapping multiple validation errors returned
// by Callback.ValidateAll() if the designated constraints aren't met.
type CallbackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackMultiError) AllErrors() []error { return m }

// CallbackValidationError is the validation error returned by
// Callback.Validate if the designated constraints aren't met.
type CallbackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackValidationError) ErrorName() string { return "CallbackValidationError" }

// Error satisfies the builtin error interface
func (e CallbackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallback.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackValidationError{}

// Validate checks the field values on PayReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayReplyMultiError, or nil
// if none found.
func (m *PayReply) ValidateAll() error {
	return m.validate(true)
}

func (m *PayReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Amount

	// no validation rules for Currency

	// no validation rules for Status

	// no validation rules for StatusCode

	// no validation rules for ChannelId

	// no validation rules for ChannelStatus

	// no validation rules for ChannelMessage

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayReplyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayReplyValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Authorization.(type) {
	case *PayReply_Redirect:
		if v == nil {
			err := PayReplyValidationError{
				field:  "Authorization",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRedirect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "Redirect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "Redirect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedirect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayReplyValidationError{
					field:  "Redirect",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PayReply_BankTransfer:
		if v == nil {
			err := PayReplyValidationError{
				field:  "Authorization",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBankTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "BankTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "BankTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBankTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayReplyValidationError{
					field:  "BankTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PayReply_QrCode:
		if v == nil {
			err := PayReplyValidationError{
				field:  "Authorization",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQrCode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "QrCode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "QrCode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQrCode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayReplyValidationError{
					field:  "QrCode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.ReferenceId != nil {
		// no validation rules for ReferenceId
	}

	if m.ChannelReferenceId != nil {
		// no validation rules for ChannelReferenceId
	}

	if m.Identity != nil {

		if all {
			switch v := interface{}(m.GetIdentity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIdentity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayReplyValidationError{
					field:  "Identity",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.PaymentMethod != nil {

		if all {
			switch v := interface{}(m.GetPaymentMethod()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "PaymentMethod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayReplyValidationError{
						field:  "PaymentMethod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPaymentMethod()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayReplyValidationError{
					field:  "PaymentMethod",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PayReplyMultiError(errors)
	}

	return nil
}

// PayReplyMultiError is an error wrapping multiple validation errors returned
// by PayReply.ValidateAll() if the designated constraints aren't met.
type PayReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayReplyMultiError) AllErrors() []error { return m }

// PayReplyValidationError is the validation error returned by
// PayReply.Validate if the designated constraints aren't met.
type PayReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayReplyValidationError) ErrorName() string { return "PayReplyValidationError" }

// Error satisfies the builtin error interface
func (e PayReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayReplyValidationError{}

// Validate checks the field values on RedirectAuthorization with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RedirectAuthorization) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RedirectAuthorization with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RedirectAuthorizationMultiError, or nil if none found.
func (m *RedirectAuthorization) ValidateAll() error {
	return m.validate(true)
}

func (m *RedirectAuthorization) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uri

	if m.ExpiresAt != nil {

		if all {
			switch v := interface{}(m.GetExpiresAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RedirectAuthorizationValidationError{
						field:  "ExpiresAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RedirectAuthorizationValidationError{
						field:  "ExpiresAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RedirectAuthorizationValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RedirectAuthorizationMultiError(errors)
	}

	return nil
}

// RedirectAuthorizationMultiError is an error wrapping multiple validation
// errors returned by RedirectAuthorization.ValidateAll() if the designated
// constraints aren't met.
type RedirectAuthorizationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RedirectAuthorizationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RedirectAuthorizationMultiError) AllErrors() []error { return m }

// RedirectAuthorizationValidationError is the validation error returned by
// RedirectAuthorization.Validate if the designated constraints aren't met.
type RedirectAuthorizationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RedirectAuthorizationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RedirectAuthorizationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RedirectAuthorizationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RedirectAuthorizationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RedirectAuthorizationValidationError) ErrorName() string {
	return "RedirectAuthorizationValidationError"
}

// Error satisfies the builtin error interface
func (e RedirectAuthorizationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRedirectAuthorization.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RedirectAuthorizationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RedirectAuthorizationValidationError{}

// Validate checks the field values on BankTransferAuthorization with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BankTransferAuthorization) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankTransferAuthorization with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BankTransferAuthorizationMultiError, or nil if none found.
func (m *BankTransferAuthorization) ValidateAll() error {
	return m.validate(true)
}

func (m *BankTransferAuthorization) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBankAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BankTransferAuthorizationValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BankTransferAuthorizationValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BankTransferAuthorizationValidationError{
				field:  "BankAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Note != nil {
		// no validation rules for Note
	}

	if m.Reference != nil {
		// no validation rules for Reference
	}

	if len(errors) > 0 {
		return BankTransferAuthorizationMultiError(errors)
	}

	return nil
}

// BankTransferAuthorizationMultiError is an error wrapping multiple validation
// errors returned by BankTransferAuthorization.ValidateAll() if the
// designated constraints aren't met.
type BankTransferAuthorizationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankTransferAuthorizationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankTransferAuthorizationMultiError) AllErrors() []error { return m }

// BankTransferAuthorizationValidationError is the validation error returned by
// BankTransferAuthorization.Validate if the designated constraints aren't met.
type BankTransferAuthorizationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankTransferAuthorizationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankTransferAuthorizationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankTransferAuthorizationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankTransferAuthorizationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankTransferAuthorizationValidationError) ErrorName() string {
	return "BankTransferAuthorizationValidationError"
}

// Error satisfies the builtin error interface
func (e BankTransferAuthorizationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankTransferAuthorization.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankTransferAuthorizationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankTransferAuthorizationValidationError{}

// Validate checks the field values on QrCodeAuthorization with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QrCodeAuthorization) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QrCodeAuthorization with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QrCodeAuthorizationMultiError, or nil if none found.
func (m *QrCodeAuthorization) ValidateAll() error {
	return m.validate(true)
}

func (m *QrCodeAuthorization) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uri

	if m.ExpiresAt != nil {

		if all {
			switch v := interface{}(m.GetExpiresAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QrCodeAuthorizationValidationError{
						field:  "ExpiresAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QrCodeAuthorizationValidationError{
						field:  "ExpiresAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QrCodeAuthorizationValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QrCodeAuthorizationMultiError(errors)
	}

	return nil
}

// QrCodeAuthorizationMultiError is an error wrapping multiple validation
// errors returned by QrCodeAuthorization.ValidateAll() if the designated
// constraints aren't met.
type QrCodeAuthorizationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QrCodeAuthorizationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QrCodeAuthorizationMultiError) AllErrors() []error { return m }

// QrCodeAuthorizationValidationError is the validation error returned by
// QrCodeAuthorization.Validate if the designated constraints aren't met.
type QrCodeAuthorizationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QrCodeAuthorizationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QrCodeAuthorizationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QrCodeAuthorizationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QrCodeAuthorizationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QrCodeAuthorizationValidationError) ErrorName() string {
	return "QrCodeAuthorizationValidationError"
}

// Error satisfies the builtin error interface
func (e QrCodeAuthorizationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQrCodeAuthorization.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QrCodeAuthorizationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QrCodeAuthorizationValidationError{}

// Validate checks the field values on ChannelReferenceId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChannelReferenceId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChannelReferenceId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChannelReferenceIdMultiError, or nil if none found.
func (m *ChannelReferenceId) ValidateAll() error {
	return m.validate(true)
}

func (m *ChannelReferenceId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelId

	// no validation rules for ReferenceId

	if len(errors) > 0 {
		return ChannelReferenceIdMultiError(errors)
	}

	return nil
}

// ChannelReferenceIdMultiError is an error wrapping multiple validation errors
// returned by ChannelReferenceId.ValidateAll() if the designated constraints
// aren't met.
type ChannelReferenceIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChannelReferenceIdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChannelReferenceIdMultiError) AllErrors() []error { return m }

// ChannelReferenceIdValidationError is the validation error returned by
// ChannelReferenceId.Validate if the designated constraints aren't met.
type ChannelReferenceIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChannelReferenceIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChannelReferenceIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChannelReferenceIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChannelReferenceIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChannelReferenceIdValidationError) ErrorName() string {
	return "ChannelReferenceIdValidationError"
}

// Error satisfies the builtin error interface
func (e ChannelReferenceIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChannelReferenceId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChannelReferenceIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChannelReferenceIdValidationError{}

// Validate checks the field values on RefundRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundRequestMultiError, or
// nil if none found.
func (m *RefundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetOrderId(), "pi_") {
		err := RefundRequestValidationError{
			field:  "OrderId",
			reason: "value does not have prefix \"pi_\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Amount != nil {
		// no validation rules for Amount
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.Note != nil {
		// no validation rules for Note
	}

	if m.ReferenceId != nil {
		// no validation rules for ReferenceId
	}

	if len(errors) > 0 {
		return RefundRequestMultiError(errors)
	}

	return nil
}

// RefundRequestMultiError is an error wrapping multiple validation errors
// returned by RefundRequest.ValidateAll() if the designated constraints
// aren't met.
type RefundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundRequestMultiError) AllErrors() []error { return m }

// RefundRequestValidationError is the validation error returned by
// RefundRequest.Validate if the designated constraints aren't met.
type RefundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundRequestValidationError) ErrorName() string { return "RefundRequestValidationError" }

// Error satisfies the builtin error interface
func (e RefundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundRequestValidationError{}

// Validate checks the field values on RefundReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundReplyMultiError, or
// nil if none found.
func (m *RefundReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Status

	// no validation rules for StatusCode

	// no validation rules for Message

	// no validation rules for ChannelStatus

	// no validation rules for ChannelReferenceId

	if m.ReferenceId != nil {
		// no validation rules for ReferenceId
	}

	if len(errors) > 0 {
		return RefundReplyMultiError(errors)
	}

	return nil
}

// RefundReplyMultiError is an error wrapping multiple validation errors
// returned by RefundReply.ValidateAll() if the designated constraints aren't met.
type RefundReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundReplyMultiError) AllErrors() []error { return m }

// RefundReplyValidationError is the validation error returned by
// RefundReply.Validate if the designated constraints aren't met.
type RefundReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundReplyValidationError) ErrorName() string { return "RefundReplyValidationError" }

// Error satisfies the builtin error interface
func (e RefundReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundReplyValidationError{}

// Validate checks the field values on VoidRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VoidRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VoidRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VoidRequestMultiError, or
// nil if none found.
func (m *VoidRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VoidRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetOrderId(), "pi_") {
		err := VoidRequestValidationError{
			field:  "OrderId",
			reason: "value does not have prefix \"pi_\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Note != nil {
		// no validation rules for Note
	}

	if len(errors) > 0 {
		return VoidRequestMultiError(errors)
	}

	return nil
}

// VoidRequestMultiError is an error wrapping multiple validation errors
// returned by VoidRequest.ValidateAll() if the designated constraints aren't met.
type VoidRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VoidRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VoidRequestMultiError) AllErrors() []error { return m }

// VoidRequestValidationError is the validation error returned by
// VoidRequest.Validate if the designated constraints aren't met.
type VoidRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VoidRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VoidRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VoidRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VoidRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VoidRequestValidationError) ErrorName() string { return "VoidRequestValidationError" }

// Error satisfies the builtin error interface
func (e VoidRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVoidRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VoidRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VoidRequestValidationError{}

// Validate checks the field values on VoidReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VoidReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VoidReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VoidReplyMultiError, or nil
// if none found.
func (m *VoidReply) ValidateAll() error {
	return m.validate(true)
}

func (m *VoidReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Status

	// no validation rules for Message

	// no validation rules for ChannelStatus

	if len(errors) > 0 {
		return VoidReplyMultiError(errors)
	}

	return nil
}

// VoidReplyMultiError is an error wrapping multiple validation errors returned
// by VoidReply.ValidateAll() if the designated constraints aren't met.
type VoidReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VoidReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VoidReplyMultiError) AllErrors() []error { return m }

// VoidReplyValidationError is the validation error returned by
// VoidReply.Validate if the designated constraints aren't met.
type VoidReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VoidReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VoidReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VoidReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VoidReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VoidReplyValidationError) ErrorName() string { return "VoidReplyValidationError" }

// Error satisfies the builtin error interface
func (e VoidReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVoidReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VoidReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VoidReplyValidationError{}

// Validate checks the field values on CaptureRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CaptureRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CaptureRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CaptureRequestMultiError,
// or nil if none found.
func (m *CaptureRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CaptureRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetOrderId(), "pi_") {
		err := CaptureRequestValidationError{
			field:  "OrderId",
			reason: "value does not have prefix \"pi_\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CaptureRequestMultiError(errors)
	}

	return nil
}

// CaptureRequestMultiError is an error wrapping multiple validation errors
// returned by CaptureRequest.ValidateAll() if the designated constraints
// aren't met.
type CaptureRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CaptureRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CaptureRequestMultiError) AllErrors() []error { return m }

// CaptureRequestValidationError is the validation error returned by
// CaptureRequest.Validate if the designated constraints aren't met.
type CaptureRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CaptureRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CaptureRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CaptureRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CaptureRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CaptureRequestValidationError) ErrorName() string { return "CaptureRequestValidationError" }

// Error satisfies the builtin error interface
func (e CaptureRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCaptureRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CaptureRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CaptureRequestValidationError{}

// Validate checks the field values on CaptureReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CaptureReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CaptureReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CaptureReplyMultiError, or
// nil if none found.
func (m *CaptureReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CaptureReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Status

	// no validation rules for Message

	if len(errors) > 0 {
		return CaptureReplyMultiError(errors)
	}

	return nil
}

// CaptureReplyMultiError is an error wrapping multiple validation errors
// returned by CaptureReply.ValidateAll() if the designated constraints aren't met.
type CaptureReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CaptureReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CaptureReplyMultiError) AllErrors() []error { return m }

// CaptureReplyValidationError is the validation error returned by
// CaptureReply.Validate if the designated constraints aren't met.
type CaptureReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CaptureReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CaptureReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CaptureReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CaptureReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CaptureReplyValidationError) ErrorName() string { return "CaptureReplyValidationError" }

// Error satisfies the builtin error interface
func (e CaptureReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCaptureReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CaptureReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CaptureReplyValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Amount

	// no validation rules for FulfillAmount

	// no validation rules for Currency

	// no validation rules for Status

	// no validation rules for StatusCode

	// no validation rules for PaymentMethodType

	// no validation rules for ChannelId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Annotation

	// no validation rules for ClientId

	switch v := m.Authorization.(type) {
	case *Transaction_Redirect:
		if v == nil {
			err := TransactionValidationError{
				field:  "Authorization",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRedirect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Redirect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Redirect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedirect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Redirect",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_BankTransfer:
		if v == nil {
			err := TransactionValidationError{
				field:  "Authorization",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBankTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BankTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BankTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBankTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "BankTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.ChannelStatus != nil {
		// no validation rules for ChannelStatus
	}

	if m.ChannelMessage != nil {
		// no validation rules for ChannelMessage
	}

	if m.ReferenceId != nil {
		// no validation rules for ReferenceId
	}

	if m.ChannelReferenceId != nil {
		// no validation rules for ChannelReferenceId
	}

	if m.Identity != nil {

		if all {
			switch v := interface{}(m.GetIdentity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIdentity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Identity",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.PaymentMethod != nil {

		if all {
			switch v := interface{}(m.GetPaymentMethod()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "PaymentMethod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "PaymentMethod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPaymentMethod()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "PaymentMethod",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Fingerprint != nil {

		if all {
			switch v := interface{}(m.GetFingerprint()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Fingerprint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Fingerprint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFingerprint()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Fingerprint",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Callback != nil {

		if all {
			switch v := interface{}(m.GetCallback()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Callback",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Callback",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCallback()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Callback",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RawResponse != nil {
		// no validation rules for RawResponse
	}

	if m.UpdatedBy != nil {
		// no validation rules for UpdatedBy
	}

	if m.UpdateReason != nil {
		// no validation rules for UpdateReason
	}

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}

	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionRequestMultiError, or nil if none found.
func (m *GetTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {

		if !strings.HasPrefix(m.GetId(), "pi_") {
			err := GetTransactionRequestValidationError{
				field:  "Id",
				reason: "value does not have prefix \"pi_\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ReferenceId != nil {
		// no validation rules for ReferenceId
	}

	if m.ChannelReferenceId != nil {

		if all {
			switch v := interface{}(m.GetChannelReferenceId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionRequestValidationError{
						field:  "ChannelReferenceId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionRequestValidationError{
						field:  "ChannelReferenceId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetChannelReferenceId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionRequestValidationError{
					field:  "ChannelReferenceId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTransactionRequestMultiError(errors)
	}

	return nil
}

// GetTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionRequestMultiError) AllErrors() []error { return m }

// GetTransactionRequestValidationError is the validation error returned by
// GetTransactionRequest.Validate if the designated constraints aren't met.
type GetTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionRequestValidationError) ErrorName() string {
	return "GetTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionRequestValidationError{}

// Validate checks the field values on GetTransactionsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionsReplyMultiError, or nil if none found.
func (m *GetTransactionsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for Skip

	// no validation rules for Limit

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsReplyValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsReplyValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsReplyValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTransactionsReplyMultiError(errors)
	}

	return nil
}

// GetTransactionsReplyMultiError is an error wrapping multiple validation
// errors returned by GetTransactionsReply.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsReplyMultiError) AllErrors() []error { return m }

// GetTransactionsReplyValidationError is the validation error returned by
// GetTransactionsReply.Validate if the designated constraints aren't met.
type GetTransactionsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsReplyValidationError) ErrorName() string {
	return "GetTransactionsReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsReplyValidationError{}

// Validate checks the field values on GetTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionsRequestMultiError, or nil if none found.
func (m *GetTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPaging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionsRequestValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionsRequestValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionsRequestValidationError{
				field:  "Paging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsRequestValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOrderBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsRequestValidationError{
						field:  fmt.Sprintf("OrderBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsRequestValidationError{
						field:  fmt.Sprintf("OrderBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsRequestValidationError{
					field:  fmt.Sprintf("OrderBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTransactionsRequestMultiError(errors)
	}

	return nil
}

// GetTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsRequestMultiError) AllErrors() []error { return m }

// GetTransactionsRequestValidationError is the validation error returned by
// GetTransactionsRequest.Validate if the designated constraints aren't met.
type GetTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsRequestValidationError) ErrorName() string {
	return "GetTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsRequestValidationError{}

// Validate checks the field values on GetTransactionRequest_ChannelReferenceId
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTransactionRequest_ChannelReferenceId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetTransactionRequest_ChannelReferenceId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetTransactionRequest_ChannelReferenceIdMultiError, or nil if none found.
func (m *GetTransactionRequest_ChannelReferenceId) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionRequest_ChannelReferenceId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelId

	// no validation rules for ReferenceId

	if len(errors) > 0 {
		return GetTransactionRequest_ChannelReferenceIdMultiError(errors)
	}

	return nil
}

// GetTransactionRequest_ChannelReferenceIdMultiError is an error wrapping
// multiple validation errors returned by
// GetTransactionRequest_ChannelReferenceId.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionRequest_ChannelReferenceIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionRequest_ChannelReferenceIdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionRequest_ChannelReferenceIdMultiError) AllErrors() []error { return m }

// GetTransactionRequest_ChannelReferenceIdValidationError is the validation
// error returned by GetTransactionRequest_ChannelReferenceId.Validate if the
// designated constraints aren't met.
type GetTransactionRequest_ChannelReferenceIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionRequest_ChannelReferenceIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionRequest_ChannelReferenceIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionRequest_ChannelReferenceIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionRequest_ChannelReferenceIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionRequest_ChannelReferenceIdValidationError) ErrorName() string {
	return "GetTransactionRequest_ChannelReferenceIdValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionRequest_ChannelReferenceIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionRequest_ChannelReferenceId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionRequest_ChannelReferenceIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionRequest_ChannelReferenceIdValidationError{}
