// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: wello-risk/risk.proto

package riskv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on EvaluateDecisionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EvaluateDecisionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EvaluateDecisionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EvaluateDecisionRequestMultiError, or nil if none found.
func (m *EvaluateDecisionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EvaluateDecisionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DecisionId

	// no validation rules for SubjectId

	// no validation rules for Scenario

	if all {
		switch v := interface{}(m.GetFeatures()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EvaluateDecisionRequestValidationError{
					field:  "Features",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EvaluateDecisionRequestValidationError{
					field:  "Features",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFeatures()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EvaluateDecisionRequestValidationError{
				field:  "Features",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EvaluateDecisionRequestMultiError(errors)
	}

	return nil
}

// EvaluateDecisionRequestMultiError is an error wrapping multiple validation
// errors returned by EvaluateDecisionRequest.ValidateAll() if the designated
// constraints aren't met.
type EvaluateDecisionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EvaluateDecisionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EvaluateDecisionRequestMultiError) AllErrors() []error { return m }

// EvaluateDecisionRequestValidationError is the validation error returned by
// EvaluateDecisionRequest.Validate if the designated constraints aren't met.
type EvaluateDecisionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EvaluateDecisionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EvaluateDecisionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EvaluateDecisionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EvaluateDecisionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EvaluateDecisionRequestValidationError) ErrorName() string {
	return "EvaluateDecisionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EvaluateDecisionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvaluateDecisionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EvaluateDecisionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EvaluateDecisionRequestValidationError{}

// Validate checks the field values on EvaluateDecisionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EvaluateDecisionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EvaluateDecisionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EvaluateDecisionResponseMultiError, or nil if none found.
func (m *EvaluateDecisionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EvaluateDecisionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Reason

	// no validation rules for ScoreComponents

	// no validation rules for OverallScore

	if len(errors) > 0 {
		return EvaluateDecisionResponseMultiError(errors)
	}

	return nil
}

// EvaluateDecisionResponseMultiError is an error wrapping multiple validation
// errors returned by EvaluateDecisionResponse.ValidateAll() if the designated
// constraints aren't met.
type EvaluateDecisionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EvaluateDecisionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EvaluateDecisionResponseMultiError) AllErrors() []error { return m }

// EvaluateDecisionResponseValidationError is the validation error returned by
// EvaluateDecisionResponse.Validate if the designated constraints aren't met.
type EvaluateDecisionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EvaluateDecisionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EvaluateDecisionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EvaluateDecisionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EvaluateDecisionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EvaluateDecisionResponseValidationError) ErrorName() string {
	return "EvaluateDecisionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EvaluateDecisionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvaluateDecisionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EvaluateDecisionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EvaluateDecisionResponseValidationError{}

// Validate checks the field values on ReportEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportEventRequestMultiError, or nil if none found.
func (m *ReportEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for SubjectId

	// no validation rules for EventType

	if all {
		switch v := interface{}(m.GetOccurredAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportEventRequestValidationError{
					field:  "OccurredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportEventRequestValidationError{
					field:  "OccurredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOccurredAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportEventRequestValidationError{
				field:  "OccurredAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportEventRequestValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportEventRequestValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportEventRequestValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportEventRequestMultiError(errors)
	}

	return nil
}

// ReportEventRequestMultiError is an error wrapping multiple validation errors
// returned by ReportEventRequest.ValidateAll() if the designated constraints
// aren't met.
type ReportEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportEventRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportEventRequestMultiError) AllErrors() []error { return m }

// ReportEventRequestValidationError is the validation error returned by
// ReportEventRequest.Validate if the designated constraints aren't met.
type ReportEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportEventRequestValidationError) ErrorName() string {
	return "ReportEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReportEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportEventRequestValidationError{}

// Validate checks the field values on ReportEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportEventResponseMultiError, or nil if none found.
func (m *ReportEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Accepted

	// no validation rules for Message

	if len(errors) > 0 {
		return ReportEventResponseMultiError(errors)
	}

	return nil
}

// ReportEventResponseMultiError is an error wrapping multiple validation
// errors returned by ReportEventResponse.ValidateAll() if the designated
// constraints aren't met.
type ReportEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportEventResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportEventResponseMultiError) AllErrors() []error { return m }

// ReportEventResponseValidationError is the validation error returned by
// ReportEventResponse.Validate if the designated constraints aren't met.
type ReportEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportEventResponseValidationError) ErrorName() string {
	return "ReportEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReportEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportEventResponseValidationError{}

// Validate checks the field values on GetLimitsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLimitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLimitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLimitsRequestMultiError, or nil if none found.
func (m *GetLimitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLimitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectId

	if len(errors) > 0 {
		return GetLimitsRequestMultiError(errors)
	}

	return nil
}

// GetLimitsRequestMultiError is an error wrapping multiple validation errors
// returned by GetLimitsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLimitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLimitsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLimitsRequestMultiError) AllErrors() []error { return m }

// GetLimitsRequestValidationError is the validation error returned by
// GetLimitsRequest.Validate if the designated constraints aren't met.
type GetLimitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLimitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLimitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLimitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLimitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLimitsRequestValidationError) ErrorName() string { return "GetLimitsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLimitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLimitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLimitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLimitsRequestValidationError{}

// Validate checks the field values on GetLimitsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLimitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLimitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLimitsResponseMultiError, or nil if none found.
func (m *GetLimitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLimitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLimits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLimitsResponseValidationError{
						field:  fmt.Sprintf("Limits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLimitsResponseValidationError{
						field:  fmt.Sprintf("Limits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLimitsResponseValidationError{
					field:  fmt.Sprintf("Limits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetLimitsResponseMultiError(errors)
	}

	return nil
}

// GetLimitsResponseMultiError is an error wrapping multiple validation errors
// returned by GetLimitsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLimitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLimitsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLimitsResponseMultiError) AllErrors() []error { return m }

// GetLimitsResponseValidationError is the validation error returned by
// GetLimitsResponse.Validate if the designated constraints aren't met.
type GetLimitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLimitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLimitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLimitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLimitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLimitsResponseValidationError) ErrorName() string {
	return "GetLimitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLimitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLimitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLimitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLimitsResponseValidationError{}

// Validate checks the field values on RiskLimit with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RiskLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RiskLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RiskLimitMultiError, or nil
// if none found.
func (m *RiskLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *RiskLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LimitId

	// no validation rules for Name

	// no validation rules for Threshold

	// no validation rules for Currency

	// no validation rules for Window

	if all {
		switch v := interface{}(m.GetRefreshedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RiskLimitValidationError{
					field:  "RefreshedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RiskLimitValidationError{
					field:  "RefreshedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RiskLimitValidationError{
				field:  "RefreshedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RiskLimitMultiError(errors)
	}

	return nil
}

// RiskLimitMultiError is an error wrapping multiple validation errors returned
// by RiskLimit.ValidateAll() if the designated constraints aren't met.
type RiskLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RiskLimitMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RiskLimitMultiError) AllErrors() []error { return m }

// RiskLimitValidationError is the validation error returned by
// RiskLimit.Validate if the designated constraints aren't met.
type RiskLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RiskLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RiskLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RiskLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RiskLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RiskLimitValidationError) ErrorName() string { return "RiskLimitValidationError" }

// Error satisfies the builtin error interface
func (e RiskLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRiskLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RiskLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RiskLimitValidationError{}

// Validate checks the field values on ListRulesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRulesRequestMultiError, or nil if none found.
func (m *ListRulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IncludeInactive

	if len(errors) > 0 {
		return ListRulesRequestMultiError(errors)
	}

	return nil
}

// ListRulesRequestMultiError is an error wrapping multiple validation errors
// returned by ListRulesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListRulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesRequestMultiError) AllErrors() []error { return m }

// ListRulesRequestValidationError is the validation error returned by
// ListRulesRequest.Validate if the designated constraints aren't met.
type ListRulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesRequestValidationError) ErrorName() string { return "ListRulesRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListRulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesRequestValidationError{}

// Validate checks the field values on ListRulesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRulesResponseMultiError, or nil if none found.
func (m *ListRulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRulesResponseValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRulesResponseValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRulesResponseValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRulesResponseMultiError(errors)
	}

	return nil
}

// ListRulesResponseMultiError is an error wrapping multiple validation errors
// returned by ListRulesResponse.ValidateAll() if the designated constraints
// aren't met.
type ListRulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesResponseMultiError) AllErrors() []error { return m }

// ListRulesResponseValidationError is the validation error returned by
// ListRulesResponse.Validate if the designated constraints aren't met.
type ListRulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesResponseValidationError) ErrorName() string {
	return "ListRulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesResponseValidationError{}

// Validate checks the field values on RiskRule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RiskRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RiskRule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RiskRuleMultiError, or nil
// if none found.
func (m *RiskRule) ValidateAll() error {
	return m.validate(true)
}

func (m *RiskRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuleId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RiskRuleValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RiskRuleValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RiskRuleValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RiskRuleMultiError(errors)
	}

	return nil
}

// RiskRuleMultiError is an error wrapping multiple validation errors returned
// by RiskRule.ValidateAll() if the designated constraints aren't met.
type RiskRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RiskRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RiskRuleMultiError) AllErrors() []error { return m }

// RiskRuleValidationError is the validation error returned by
// RiskRule.Validate if the designated constraints aren't met.
type RiskRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RiskRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RiskRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RiskRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RiskRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RiskRuleValidationError) ErrorName() string { return "RiskRuleValidationError" }

// Error satisfies the builtin error interface
func (e RiskRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRiskRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RiskRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RiskRuleValidationError{}

// Validate checks the field values on EvaluateVelocityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EvaluateVelocityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EvaluateVelocityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EvaluateVelocityRequestMultiError, or nil if none found.
func (m *EvaluateVelocityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EvaluateVelocityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectId

	// no validation rules for Action

	// no validation rules for Channel

	// no validation rules for Window

	// no validation rules for Count

	if all {
		switch v := interface{}(m.GetObservedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EvaluateVelocityRequestValidationError{
					field:  "ObservedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EvaluateVelocityRequestValidationError{
					field:  "ObservedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EvaluateVelocityRequestValidationError{
				field:  "ObservedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EvaluateVelocityRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EvaluateVelocityRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EvaluateVelocityRequestValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EvaluateVelocityRequestMultiError(errors)
	}

	return nil
}

// EvaluateVelocityRequestMultiError is an error wrapping multiple validation
// errors returned by EvaluateVelocityRequest.ValidateAll() if the designated
// constraints aren't met.
type EvaluateVelocityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EvaluateVelocityRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EvaluateVelocityRequestMultiError) AllErrors() []error { return m }

// EvaluateVelocityRequestValidationError is the validation error returned by
// EvaluateVelocityRequest.Validate if the designated constraints aren't met.
type EvaluateVelocityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EvaluateVelocityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EvaluateVelocityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EvaluateVelocityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EvaluateVelocityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EvaluateVelocityRequestValidationError) ErrorName() string {
	return "EvaluateVelocityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EvaluateVelocityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvaluateVelocityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EvaluateVelocityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EvaluateVelocityRequestValidationError{}

// Validate checks the field values on EvaluateVelocityResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EvaluateVelocityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EvaluateVelocityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EvaluateVelocityResponseMultiError, or nil if none found.
func (m *EvaluateVelocityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EvaluateVelocityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Allowed

	// no validation rules for PolicyId

	// no validation rules for Reason

	// no validation rules for AnomalyScores

	if len(errors) > 0 {
		return EvaluateVelocityResponseMultiError(errors)
	}

	return nil
}

// EvaluateVelocityResponseMultiError is an error wrapping multiple validation
// errors returned by EvaluateVelocityResponse.ValidateAll() if the designated
// constraints aren't met.
type EvaluateVelocityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EvaluateVelocityResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EvaluateVelocityResponseMultiError) AllErrors() []error { return m }

// EvaluateVelocityResponseValidationError is the validation error returned by
// EvaluateVelocityResponse.Validate if the designated constraints aren't met.
type EvaluateVelocityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EvaluateVelocityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EvaluateVelocityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EvaluateVelocityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EvaluateVelocityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EvaluateVelocityResponseValidationError) ErrorName() string {
	return "EvaluateVelocityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EvaluateVelocityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvaluateVelocityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EvaluateVelocityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EvaluateVelocityResponseValidationError{}
